-- Algebra generated by a set.
open import UnivAlgebra
open import Level renaming (zero to lzero ; suc to lsuc)
open import Equational
module SubAlgebra {lsig lops lvars â„“â‚ â„“â‚‚}{Î£ : Sign lsig lops} {X : ğ“¥ Î£ lvars} (A : Alg {â„“â‚} {â„“â‚‚} Î£) where

open import Relation.Binary
open import Relation.Unary renaming (_âŠ†_ to _âŠ†r_) hiding (_â‡’_)
open import Data.Product renaming (map to Ã—f) hiding(Î£)
open import Data.List
open import Function as F hiding (Injective; Bijective; Surjective;module Injection;Injection)
open import Function.Equality as FE renaming (_âˆ˜_ to _âˆ˜â‚›_) hiding (setoid;_â‡¨_)
open import Function.Bijection hiding (_âˆ˜_)
open import Function.Surjection hiding (_âˆ˜_)
open import Function.Injection hiding (_âˆ˜_)

open import Morphisms
open import Setoids
open import HeterogeneousVec renaming (map to mapV)

open SetoidPredicate
Predicate : (â„“â‚ƒ : Level) â†’ Set (lsig âŠ” lsuc (â„“â‚ âŠ” â„“â‚‚ âŠ” â„“â‚ƒ))
Predicate â„“â‚ƒ = (s : sorts Î£) â†’ SetoidPredicate {â„“â‚ƒ = â„“â‚ƒ} (A âŸ¦ s âŸ§â‚›)

_âŠ†â‚š_ : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ Predicate â„“â‚ƒ â†’ Predicate â„“â‚„ â†’ Set (lsig âŠ” â„“â‚ âŠ” â„“â‚ƒ âŠ” â„“â‚„)
P âŠ†â‚š Q = (s : sorts Î£) â†’ predicate (P s) âŠ†r predicate (Q s)

_âŠ†â‚š*_ : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ Predicate â„“â‚ƒ â†’ Predicate â„“â‚„ â†’ Set (lsig âŠ” â„“â‚ âŠ” â„“â‚ƒ âŠ” â„“â‚„)
P âŠ†â‚š* Q = âˆ€ ar â†’ ((predicate âˆ˜ P) â‡¨v ) {is = ar} âŠ†r ((predicate âˆ˜ Q) â‡¨v ) {is = ar}

IxPredicate : (â„“â‚ƒ â„“â‚„ : Level) â†’ Set _
IxPredicate â„“â‚ƒ â„“â‚„ = Pred (Predicate  â„“â‚ƒ) â„“â‚„

-- The Intersection of an OpClosed family of predicates is OpClosed.
â‹‚p : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ IxPredicate â„“â‚ƒ â„“â‚„ â†’ Predicate _
â‹‚p P s = record {  predicate = Î» x â†’ âˆ€ Q â†’ P Q â†’ predicate (Q s) x
                 ; predWellDef = Î» eq p Q â†’ predWellDef (Q s) eq âˆ˜ p Q
                 }

â‹‚-OpClosed : âˆ€ {â„“â‚ƒ â„“â‚„} (P : IxPredicate â„“â‚ƒ â„“â‚„) â†’
             (âˆ€ Q â†’ P Q â†’ OpClosed A (predicate âˆ˜ Q)) â†’
             OpClosed A (predicate âˆ˜ â‹‚p {â„“â‚ƒ = â„“â‚ƒ} {â„“â‚„} P)
â‹‚-OpClosed P isClosed f vs Q pQ = isClosed Q pQ f (mapâ‡¨v (Î» v â†’ v Q pQ) vs)

open SubAlg
â‹‚-SubAlg : âˆ€ {â„“â‚ƒ â„“â‚„} (P : IxPredicate â„“â‚ƒ â„“â‚„) â†’
             (âˆ€ Q â†’ P Q â†’ OpClosed A (predicate âˆ˜ Q)) â†’
             SubAlg {â„“â‚ƒ = lsig âŠ” lsuc â„“â‚ âŠ” lsuc â„“â‚‚ âŠ” lsuc â„“â‚ƒ âŠ” â„“â‚„} A
â‹‚-SubAlg {â„“â‚ƒ} {â„“â‚„} P isClosed = record
             { pr = â‹‚p {â„“â‚ƒ} {â„“â‚„} P
             ; opClosed = â‹‚-OpClosed {â„“â‚ƒ} P isClosed
             }
â‹‚-SubAlg' : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ (P : Pred (SubAlg {â„“â‚ƒ = â„“â‚ƒ} A) â„“â‚„) â†’
              SubAlg {â„“â‚ƒ = lsuc lsig âŠ” lsuc lops âŠ” lsuc â„“â‚ âŠ” lsuc â„“â‚‚ âŠ” lsuc â„“â‚ƒ âŠ” â„“â‚„} A
â‹‚-SubAlg' {â„“â‚ƒ} {â„“â‚„} P = record
             { pr = pred
             ; opClosed = Î» f vs Q pq â†’ opClosed Q f (mapâ‡¨v (Î» v â†’ v Q pq) vs)
             }
     where pred : Predicate _
           pred s = record { predicate = Î» x â†’ âˆ€ Q â†’ P Q â†’ predicate (pr Q s) x
                           ; predWellDef = Î» eq pres Q â†’ predWellDef (pr Q s) eq âˆ˜ pres Q
                           }


-- Algebra generated by a SetoidPredicate (not necessarily OpClosed).
<_>_ : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ (X : Predicate â„“â‚ƒ) â†’ (P : Pred (SubAlg {â„“â‚ƒ = â„“â‚ƒ} A) â„“â‚„) â†’
         SubAlg {â„“â‚ƒ = _} A
<_>_ {â„“â‚ƒ = â„“â‚ƒ} {â„“â‚„} X P = â‹‚-SubAlg' Î» Q â†’ P Q Ã— (X âŠ†â‚š pr Q)

-- Inductive definition.

data E {â„“â‚ƒ} (X : Predicate â„“â‚ƒ) (s : sorts Î£) : Setoid.Carrier (A âŸ¦ s âŸ§â‚›) â†’ Set (lsig âŠ” lops âŠ” â„“â‚ âŠ” â„“â‚‚ âŠ” â„“â‚ƒ) where
  inX : âˆ€ {a} â†’ predicate (X s) a â†’ E X s a
  img : âˆ€ {a} {ar} {f : ops Î£ (ar , s)} (ts : HVec (Î» x â†’ âˆƒ (Î» a' â†’ E X x a')) ar) â†’
          Setoid._â‰ˆ_ (A âŸ¦ s âŸ§â‚›) ((A âŸ¦ f âŸ§â‚’ âŸ¨$âŸ© mapV (Î» _ â†’ projâ‚) ts)) a â†’
              E X s a


E-WellDefined : âˆ€ {â„“â‚ƒ}â†’ (X : Predicate â„“â‚ƒ) â†’ (s : sorts Î£) â†’ WellDef (A âŸ¦ s âŸ§â‚›) (E X s)
E-WellDefined X s {y = y} aâ‰ˆb (inX x) = inX (predWellDef (X s) aâ‰ˆb x)
E-WellDefined X s {y = y} aâ‰ˆb (img ts aâ‰ˆf-ts) = img ts (trans aâ‰ˆf-ts aâ‰ˆb)
  where open Setoid (A âŸ¦ s âŸ§â‚›)

E-Pred : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’ Predicate _
E-Pred X s = record { predicate = E X s
                    ; predWellDef = E-WellDefined X s
                    }

XâŠ†E : âˆ€ {â„“â‚ƒ} (X : Predicate â„“â‚ƒ) â†’ X âŠ†â‚š E-Pred X
XâŠ†E X s aâˆˆX = inX aâˆˆX

E-opClosed : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’ OpClosed A (predicate âˆ˜ E-Pred X)
E-opClosed X {ar} {s} f {ts} tsp = img {f = f} (â‡¨vtoÎ£ tsp) prop
  where open Setoid (A âŸ¦ s âŸ§â‚›)
        prop : (A âŸ¦ f âŸ§â‚’) âŸ¨$âŸ© mapV (Î» _ â†’ projâ‚) (â‡¨vtoÎ£ tsp) â‰ˆ (A âŸ¦ f âŸ§â‚’) âŸ¨$âŸ© ts
        prop rewrite projâ‚-inv-â‡¨vtoÎ£ tsp = refl


E-SubAlg : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’ SubAlg {â„“â‚ƒ = lsig âŠ” lops âŠ” â„“â‚ âŠ” â„“â‚‚ âŠ” â„“â‚ƒ} A
E-SubAlg X = record { pr = E-Pred X ; opClosed = E-opClosed X }

-- Algebra generated by a SetoidPredicate (not necessarily OpClosed).
âŸ¨_âŸ© : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’ Alg Î£
âŸ¨_âŸ© {â„“â‚ƒ = â„“â‚ƒ} X  = SubAlgebra (E-SubAlg X)

-- Equivalence between â‹‚-SubAlg' and E-SubAlg, stated in terms of predicates.
EâŠ†â‹‚-Sub : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’
        pr (â‹‚-SubAlg' {â„“â‚ƒ = lsig âŠ” lops âŠ” â„“â‚ âŠ” â„“â‚‚ âŠ” â„“â‚ƒ } (Î» Q â†’ X âŠ†â‚š pr Q)) âŠ†â‚š E-Pred X
EâŠ†â‹‚-Sub X s a = a (E-SubAlg X) (XâŠ†E X)

â‹‚-SubâŠ†E : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’
        E-Pred X âŠ†â‚š
        pr (â‹‚-SubAlg' {â„“â‚ƒ = â„“â‚ âŠ” â„“â‚‚ âŠ” â„“â‚ƒ } (Î» Q â†’ X âŠ†â‚š pr Q))
â‹‚-SubâŠ†E* : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’ âˆ€ Q â†’ X âŠ†â‚š pr Q â†’
         âˆ€ {ar}
        (ts : HVec (Î» x â†’ âˆƒ (Î» a' â†’ E X x a')) ar) â†’
        (predicate âˆ˜ pr Q) â‡¨v mapV (Î» _ â†’ projâ‚) ts

â‹‚-SubâŠ†E X s (inX x) Q XâŠ†Q = XâŠ†Q s x
â‹‚-SubâŠ†E X s (img {a} {ar} {f} tsE x) Q XâŠ†Q = predWellDef (pr Q s) x f-tsQ
  where f-tsQ : predicate (pr Q s) ((A âŸ¦ f âŸ§â‚’) âŸ¨$âŸ© mapV (Î» _ â†’ projâ‚) tsE)
        f-tsQ = opClosed Q f (â‹‚-SubâŠ†E* X Q XâŠ†Q tsE )

â‹‚-SubâŠ†E* X Q XâŠ†Q âŸ¨âŸ© = â‡¨vâŸ¨âŸ©
â‹‚-SubâŠ†E* X Q XâŠ†Q {s âˆ· _} (v â–¹ ts) = â‡¨vâ–¹ (â‹‚-SubâŠ†E X s (projâ‚‚ v) Q XâŠ†Q)
                                            (â‹‚-SubâŠ†E* X Q XâŠ†Q ts)


â‰…-SubAlg : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ (B : SubAlg {â„“â‚ƒ = â„“â‚ƒ} A) â†’ (C : SubAlg {â„“â‚ƒ = â„“â‚„} A) â†’ Set _
â‰…-SubAlg B C = pr B âŠ†â‚š pr C Ã— pr C âŠ†â‚š pr B

â‰…-SubAlg-iso : âˆ€ {â„“â‚ƒ â„“â‚„} â†’ (B : SubAlg {â„“â‚ƒ = â„“â‚ƒ} A) â†’ (C : SubAlg {â„“â‚ƒ = â„“â‚„} A) â†’
               â‰…-SubAlg B C â†’ Isomorphism (SubAlgebra B) (SubAlgebra C)
â‰…-SubAlg-iso {â„“â‚ƒ} {â„“â‚„} B C (Bâ‰¤C , Câ‰¤B) =
               record { hom = H
                      ; bij = Î» s â†’ record { injective = F.id
                                           ; surjective = isSurj s
                                           }
                      }
   where open Hom
         open Homo
         â€²Hâ€² : âˆ€ s â†’ (SubAlgebra B) âŸ¦ s âŸ§â‚› âŸ¶ (SubAlgebra C) âŸ¦ s âŸ§â‚›
         â€²Hâ€² s = record { _âŸ¨$âŸ©_ = Ã—f F.id (Bâ‰¤C s)
                        ; cong = F.id
                        }
         Hcond : homCond (SubAlgebra B) (SubAlgebra C) â€²Hâ€²
         Hcond {s = s} f as
           rewrite propMapVâˆ˜ as (Î» i â†’ Ã—f F.id (Bâ‰¤C i)) (Î» _ â†’ projâ‚) = Setoid.refl (A âŸ¦ s âŸ§â‚›)
         H : Homo (SubAlgebra B) (SubAlgebra C)
         H = record { â€²_â€² = â€²Hâ€²
                    ; cond = Hcond
                    }

         Hâ»Â¹ : âˆ€ s â†’ (SubAlgebra C) âŸ¦ s âŸ§â‚› âŸ¶ (SubAlgebra B) âŸ¦ s âŸ§â‚›
         Hâ»Â¹ s = record { _âŸ¨$âŸ©_ = Ã—f F.id (Câ‰¤B s)
                        ; cong = F.id
                        }
         isSurj : âˆ€ s â†’ Surjective (â€² H â€² s)
         isSurj s = record { from = Hâ»Â¹ s
                           ; right-inverse-of = Î» _ â†’ Setoid.refl (A âŸ¦ s âŸ§â‚›)
                           }
open Universe Î£
_âŠ†â‚›_ : âˆ€ {â„“â‚} {â„“â‚‚} {â„“â‚ƒ} {â„“â‚„} â†’ Universe â„“â‚ â„“â‚‚ â†’ Universe â„“â‚ƒ â„“â‚„ â†’ Set _
_âŠ†â‚›_ {â„“â‚} {â„“â‚‚} {â„“â‚ƒ} {â„“â‚„} X A = âˆ€ {s} â†’ Injection {â„“â‚} {â„“â‚‚} {â„“â‚ƒ} {â„“â‚„} (X s) (A s)

Img : âˆ€ {â„“â‚ƒ} {â„“â‚„} {X : Universe â„“â‚ƒ â„“â‚„} â†’ (X âŠ†â‚› (A âŸ¦_âŸ§â‚›)) â†’ Predicate (â„“â‚‚ âŠ” â„“â‚ƒ)
Img {X} XâŠ†â‚›A s = record { predicate = Î» a â†’ âˆƒ (Î» x â†’ a â‰ˆ (to âŸ¨$âŸ© x))
                        ; predWellDef = Î» { eq (x , eq') â†’ x , trans (sym eq) eq' }
                        }
    where open Injection (XâŠ†â‚›A {s})
          open Setoid (A âŸ¦ s âŸ§â‚›)

âŸ¨_âŸ©' : âˆ€ {â„“â‚ƒ} {â„“â‚„} {X : Universe â„“â‚ƒ â„“â‚„} â†’ (X âŠ†â‚› (A âŸ¦_âŸ§â‚›)) â†’ Alg Î£
âŸ¨ XâŠ†A âŸ©' = âŸ¨ Img XâŠ†A âŸ©

open Setoid

module Free {â„“â‚ƒ} {â„“â‚„} {X : Universe â„“â‚ƒ â„“â‚„} where
  data Free  : (s : sorts Î£) â†’ Set (â„“â‚ƒ âŠ” â„“â‚„ âŠ” lsig âŠ” lops)  where
    var : âˆ€ {s : sorts Î£} (x : Carrier (X s)) â†’  Free s
    app : âˆ€ {ar s} â†’  (f : ops Î£ (ar â†¦ s)) â†’ (HVec Free ar) â†’ Free s

  data â‰ˆF : (s : sorts Î£) â†’ Rel (Free s) (lsig âŠ” lops âŠ” â„“â‚ƒ âŠ” â„“â‚„) where
    â‰ˆvar : âˆ€ {s} {x y} â†’ _â‰ˆ_ (X s) x y â†’ â‰ˆF s (var x) (var y)
    â‰ˆfun : âˆ€ {ar} {s} â†’ (f : ops Î£ (ar â†¦ s)) â†’
             âˆ€ {ts ts' : HVec Free ar} â†’ _âˆ¼v_ {R = â‰ˆF} ts ts' â†’
             â‰ˆF s (app f ts) (app f ts')

  isRefl : âˆ€ s â†’ Reflexive (â‰ˆF s)
  isRefl* : âˆ€ ar â†’ Reflexive (_âˆ¼v_ {R = â‰ˆF} {is = ar})
  isRefl* [] {x = âŸ¨âŸ©} = âˆ¼âŸ¨âŸ©
  isRefl* (s âˆ· ar) {x = v â–¹ x} = âˆ¼â–¹ (isRefl s {v}) (isRefl* ar {x})
  isRefl s {var x} = â‰ˆvar (refl (X s))
  isRefl s {app {ar} f x} = â‰ˆfun f (isRefl* ar {x})
  isSym : âˆ€ s â†’ Symmetric (â‰ˆF s)
  isSym* : âˆ€ ar â†’ Symmetric (_âˆ¼v_ {R = â‰ˆF} {is = ar})
  isSym s (â‰ˆvar x) = â‰ˆvar (sym (X s) x)
  isSym s (â‰ˆfun {ar} f x) = â‰ˆfun f (isSym* ar x)
  isSym* [] âˆ¼âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
  isSym* (s âˆ· ar) (âˆ¼â–¹ eq eqs) = âˆ¼â–¹ (isSym s eq) (isSym* ar eqs)
  isTrans : âˆ€ s â†’ Transitive (â‰ˆF s)
  isTrans* : âˆ€ ar â†’ Transitive (_âˆ¼v_ {R = â‰ˆF} {is = ar})
  isTrans* [] âˆ¼âŸ¨âŸ© âˆ¼âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
  isTrans* (s âˆ· ar) (âˆ¼â–¹ eq eqs) (âˆ¼â–¹ eq' eqs') = âˆ¼â–¹ (isTrans s eq eq') (isTrans* ar eqs eqs')
  isTrans s (â‰ˆvar eq) (â‰ˆvar eq') = â‰ˆvar (trans (X s) eq eq')
  isTrans s (â‰ˆfun {ar} f eqs) (â‰ˆfun {.ar} .f eqs') = â‰ˆfun f (isTrans* ar eqs eqs')

  â‰ˆFisEquiv : âˆ€ s â†’ IsEquivalence (â‰ˆF s)
  â‰ˆFisEquiv s = record { refl = isRefl s
                       ; sym = isSym s
                       ; trans = isTrans s
                       }

  freeSetoid : (s : sorts Î£) â†’ Setoid (lsig âŠ” lops âŠ” â„“â‚ƒ âŠ” â„“â‚„) (lsig âŠ” lops âŠ” â„“â‚ƒ âŠ” â„“â‚„)
  freeSetoid s = record { Carrier = Free s
                      ; _â‰ˆ_ = â‰ˆF s
                      ; isEquivalence = â‰ˆFisEquiv s
                      }

  freeAlgebra : Alg {lsig âŠ” lops âŠ” â„“â‚ƒ âŠ” â„“â‚„} {lsig âŠ” lops âŠ” â„“â‚ƒ âŠ” â„“â‚„} Î£
  freeAlgebra = record { _âŸ¦_âŸ§â‚› = freeSetoid
                       ; _âŸ¦_âŸ§â‚’ = âˆ£_âˆ£o
                       }
   where âˆ£_âˆ£o  : âˆ€ {ar s} â†’ ops Î£ (ar â†¦ s) â†’ freeSetoid âœ³ ar âŸ¶ freeSetoid s
         âˆ£ f âˆ£o = record { _âŸ¨$âŸ©_ = app f
                       ; cong = â‰ˆfun f
                       }




module FreeExt {â„“â‚ƒ} {â„“â‚„} {X : Universe â„“â‚ƒ â„“â‚„} {â„“â‚ â„“â‚‚} (B : Alg {â„“â‚} {â„“â‚‚} Î£) (Î¸ : X âŠ†â‚› (B âŸ¦_âŸ§â‚›)) where
  open Free {X = X}
  open Injection
  open Hom
  open Homo

  open Injection
  mutual
    âˆ£hâˆ£â†’A : âˆ€ {s} â†’ Free s â†’ âˆ¥ B âŸ¦ s âŸ§â‚› âˆ¥
    âˆ£hâˆ£â†’A (var {s} x) = to (Î¸ {s}) âŸ¨$âŸ© x
    âˆ£hâˆ£â†’A (app f x) = B âŸ¦ f âŸ§â‚’ âŸ¨$âŸ© map|h|â†’A x

    map|h|â†’A : âˆ€ {ar} â†’ HVec Free ar â†’ B âŸ¦ ar âŸ§â‚›*
    map|h|â†’A âŸ¨âŸ© = âŸ¨âŸ©
    map|h|â†’A (t â–¹ ts) = âˆ£hâˆ£â†’A t â–¹ map|h|â†’A ts

  congfun : âˆ€ {s} {tâ‚ tâ‚‚ : Free s} â†’ â‰ˆF s tâ‚ tâ‚‚ â†’ _â‰ˆ_ (B âŸ¦ s âŸ§â‚›) (âˆ£hâˆ£â†’A tâ‚) (âˆ£hâˆ£â†’A tâ‚‚)
  congfun* : âˆ€ {ar} {tâ‚ tâ‚‚ : HVec Free ar} â†’  _âˆ¼v_ {R = â‰ˆF} tâ‚ tâ‚‚ â†’
                                              _âˆ¼v_ {R = Î» s â†’ _â‰ˆ_ (B âŸ¦ s âŸ§â‚›)} (map|h|â†’A tâ‚) (map|h|â†’A tâ‚‚)
  congfun* {.[]} âˆ¼âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
  congfun* {.(_ âˆ· _)} (âˆ¼â–¹ eq eqs) = âˆ¼â–¹ (congfun eq) (congfun* eqs)
  congfun {s} (â‰ˆvar x) = cong (to (Î¸ {s})) x
  congfun {s} (â‰ˆfun f x) = cong (B âŸ¦ f âŸ§â‚’) (congfun* x)
  fun|T|â‚• : freeAlgebra âŸ¿ B
  fun|T|â‚• s = record { _âŸ¨$âŸ©_ = âˆ£hâˆ£â†’A {s = s}
                     ; cong  = congfun {s}
                     }

  map|h|-â‰ˆ : âˆ€ {ar} ts â†’ _âˆ¼v_ {R = Î» s â†’ _â‰ˆ_ (B âŸ¦ s âŸ§â‚›)} {is = ar} (map|h|â†’A ts) (mapV (Î» x â†’ âˆ£hâˆ£â†’A) ts)
  map|h|-â‰ˆ âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
  map|h|-â‰ˆ {s âˆ· _} (v â–¹ ts) = âˆ¼â–¹ (refl (B âŸ¦ s âŸ§â‚›)) (map|h|-â‰ˆ ts)
  |T|â‚•cond : (homCond freeAlgebra B) fun|T|â‚•
  |T|â‚•cond {_} {s} f ts = cong (B âŸ¦ f âŸ§â‚’) (map|h|-â‰ˆ ts)

  open Hom
  âˆ£Hâˆ£ : Homo freeAlgebra B
  âˆ£Hâˆ£ = record { â€²_â€²  = fun|T|â‚•
                 ; cond = |T|â‚•cond
                 }

  extends-Î¸ : (H : Homo freeAlgebra B) â†’ Set _
  extends-Î¸ H = âˆ€ s (x : Carrier (X s)) â†’
            Setoid._â‰ˆ_ (B âŸ¦ s âŸ§â‚›) (â€² H â€² s âŸ¨$âŸ© var x) (to Î¸ âŸ¨$âŸ© x)

  import Relation.Binary.EqReasoning as EqR

  _â‰ˆh_ : _
  _â‰ˆh_ = _â‰ˆâ‚•_ freeAlgebra B
  UMP : âˆ€ (H : Homo freeAlgebra B) â†’ extends-Î¸ H â†’ H â‰ˆh âˆ£Hâˆ£
  UMP H prop s (var x) = prop s x
  UMP H prop s (app {ar} f ts) =
          begin
            â€² H â€² s âŸ¨$âŸ© app f ts
              â‰ˆâŸ¨ cond H f ts âŸ©
            B âŸ¦ f âŸ§â‚’ âŸ¨$âŸ© mapV (_âŸ¨$âŸ©_ âˆ˜ â€² H â€²) ts
              â‰ˆâŸ¨ Î .cong (B âŸ¦ f âŸ§â‚’) (mapâ‰ˆ ar ts) âŸ©
            â€² âˆ£Hâˆ£ â€² s âŸ¨$âŸ© app f ts
          âˆ
    where open EqR (B âŸ¦ s âŸ§â‚›)
          mapâ‰ˆ : (ar : Arity Î£) â†’ (ts : HVec Free ar) â†’
                 (mapV (_âŸ¨$âŸ©_ âˆ˜ â€² H â€²) ts) âˆ¼v (map|h|â†’A ts)
          mapâ‰ˆ [] âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
          mapâ‰ˆ (s âˆ· ar) (t â–¹ ts) = âˆ¼â–¹ (UMP H prop s t) (mapâ‰ˆ ar ts) 


module Gen {â„“â‚ƒ â„“â‚„ : Level} {X : Universe â„“â‚ƒ â„“â‚„} (Î¹ : X âŠ†â‚› (A âŸ¦_âŸ§â‚›))  where
  open Free {X = X}
  open FreeExt A Î¹
  open Hom
  open Setoid
  open Injection


  âŠ†E : âˆ€ s t â†’ predicate (E-Pred (Img Î¹) s) (âˆ£hâˆ£â†’A t)
  âŠ†E* : âˆ€ ar (ts : HVec Free ar) â†’ HVec ((Î» x â†’ âˆƒ (Î» a' â†’ E (Img Î¹) x a'))) ar
  projâ‚âŠ†E* : âˆ€ ar (ts : HVec Free ar) â†’
       _â‰ˆ_ ((Î» s â†’ A âŸ¦ s âŸ§â‚›) âœ³ ar) (mapV (Î» _ â†’ projâ‚) (âŠ†E* ar ts)) (map|h|â†’A ts)
  âŠ†E* [] âŸ¨âŸ© = âŸ¨âŸ©
  âŠ†E* (x âˆ· ar) (v â–¹ ts) = (âˆ£hâˆ£â†’A v , âŠ†E x v) â–¹ âŠ†E* ar ts
  projâ‚âŠ†E* [] âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
  projâ‚âŠ†E* (s âˆ· ar) (v â–¹ ts) = âˆ¼â–¹ (refl (A âŸ¦ s âŸ§â‚›)) (projâ‚âŠ†E* ar ts )
  âŠ†E s (var x) = inX (x , refl (A âŸ¦ s âŸ§â‚›))
  âŠ†E s (app {ar = ar} f ts) = img {f = f} (âŠ†E* ar ts) (cong (A âŸ¦ f âŸ§â‚’) (projâ‚âŠ†E* ar ts))

  âŠ‡E : âˆ€ s a â†’ predicate (E-Pred (Img Î¹) s) a â†’ âˆƒ (Î» t â†’ _â‰ˆ_ (A âŸ¦ s âŸ§â‚›) a (âˆ£hâˆ£â†’A t))
  âŠ‡E*1 : âˆ€ ar (ts : HVec (Î» xâ‚ â†’ âˆƒ (E (Img Î¹) xâ‚)) ar) â†’
    HVec Free ar
  âŠ‡E* : âˆ€ ar (ts : HVec (Î» xâ‚ â†’ âˆƒ (E (Img Î¹) xâ‚)) ar) â†’
    HVec (Î» x â†’ âˆƒ (Î» a â†’ âˆƒ (Î» t â†’ _â‰ˆ_ (A âŸ¦ x âŸ§â‚›) a (âˆ£hâˆ£â†’A t)))) ar
  projâ‚âŠ‡E* : âˆ€ ar (ts : HVec (Î» xâ‚ â†’ âˆƒ (E (Img Î¹) xâ‚)) ar) â†’
       _â‰ˆ_ ((Î» s â†’ A âŸ¦ s âŸ§â‚›) âœ³ ar) (mapV (Î» _ â†’ projâ‚) ts)
                 (map|h|â†’A (âŠ‡E*1 ar ts))
  âŠ‡E*1 [] âŸ¨âŸ© = âŸ¨âŸ©
  âŠ‡E*1 (x âˆ· ar) ((a , p) â–¹ ts) = (projâ‚ (âŠ‡E x a p)) â–¹ âŠ‡E*1 ar ts
  âŠ‡E* [] âŸ¨âŸ© = âŸ¨âŸ©
  âŠ‡E* (x âˆ· ar) ((a , p) â–¹ ts) = (a , âŠ‡E x a p) â–¹ âŠ‡E* ar ts
  projâ‚âŠ‡E* [] âŸ¨âŸ© = âˆ¼âŸ¨âŸ©
  projâ‚âŠ‡E* (x âˆ· ar) ((a , p) â–¹ ts) = âˆ¼â–¹ (projâ‚‚ (âŠ‡E x a p)) (projâ‚âŠ‡E* ar ts)
  âŠ‡E s a (inX (x , eq)) = var x , eq
  âŠ‡E s a (img {ar = ar} {f} ts x) =
    (app f (âŠ‡E*1 ar ts)) , trans (A âŸ¦ s âŸ§â‚›) (sym (A âŸ¦ s âŸ§â‚›) x) (Î .cong (A âŸ¦ f âŸ§â‚’) (projâ‚âŠ‡E* ar ts))


  EâŠ†H : E-Pred (Img Î¹) âŠ†â‚š  pr (SubImg freeAlgebra A âˆ£Hâˆ£)
  EâŠ†H s {a} p = projâ‚ (âŠ‡E s a p) , sym (A âŸ¦ s âŸ§â‚›) (projâ‚‚ (âŠ‡E s a p))
  HâŠ†E : pr (SubImg freeAlgebra A âˆ£Hâˆ£) âŠ†â‚š E-Pred (Img Î¹)
  HâŠ†E s {a} (t , eq) = E-WellDefined (Img Î¹) s eq (âŠ†E s t)

  âŸ¨Î¹âŸ©â‰…ImgÎ¹ : âŸ¨ Î¹ âŸ©' â‰… homImg freeAlgebra âˆ£Hâˆ£
  âŸ¨Î¹âŸ©â‰…ImgÎ¹ = record { iso = â‰…-SubAlg-iso (E-SubAlg (Img Î¹)) (SubImg freeAlgebra A âˆ£Hâˆ£) (EâŠ†H , HâŠ†E) }

-- A is generated by X if âˆ€ a âˆˆ A, E a
IsGeneratedBy : âˆ€ {â„“â‚ƒ} â†’ (X : Predicate â„“â‚ƒ) â†’ Set _
IsGeneratedBy X = âˆ€ s a â†’ E X s a
