-- Algebra generated by a set.
open import UnivAlgebra
open import Level renaming (zero to lzero ; suc to lsuc)
module SubAlgebra (Σ₁ : Signature) {ℓ₁ ℓ₂ : Level} (A : Algebra {ℓ₁} {ℓ₂} Σ₁) where

open import Relation.Binary
open import Relation.Unary renaming (_⊆_ to _⊆r_) hiding (_⇒_)
open import Data.Product hiding (map)
open import Function as F hiding (Bijective; Surjective; Bijection; Surjection)
open import Function.Equality as FE renaming (_∘_ to _∘ₛ_) hiding (setoid)
open import Equational
open import Product
open import Morphisms
open import Setoids
open import HeterogeneousVec renaming (map to mapV)
open Signature
open ProdAlg
open Hom
open Algebra

open SetoidPredicate
Predicate : (ℓ₃ : Level) → Set (lsuc (ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃))
Predicate ℓ₃ = (s : sorts Σ₁) → SetoidPredicate {ℓ₃ = ℓ₃} (A ⟦ s ⟧ₛ)

_⊆ₚ_ : ∀ {ℓ₃ ℓ₄} → Predicate ℓ₃ → Predicate ℓ₄ → Set (ℓ₁ ⊔ ℓ₃ ⊔ ℓ₄)
P ⊆ₚ Q = (s : sorts Σ₁) → predicate (P s) ⊆r predicate (Q s)

IxPredicate : (ℓ₃ ℓ₄ : Level) → Set _
IxPredicate ℓ₃ ℓ₄ = Pred (Predicate  ℓ₃) ℓ₄

-- The Intersection of an OpClosed family of predicates is OpClosed.
⋂p : ∀ {ℓ₃ ℓ₄} → IxPredicate ℓ₃ ℓ₄ → Predicate _
⋂p P s = record {  predicate = λ x → ∀ Q → P Q → predicate (Q s) x
                 ; predWellDef = λ eq p Q → predWellDef (Q s) eq ∘ p Q
                 }

⋂-OpClosed : ∀ {ℓ₃ ℓ₄} (P : IxPredicate ℓ₃ ℓ₄) →
             (∀ Q → P Q → OpClosed A (predicate ∘ Q)) →
             OpClosed A (predicate ∘ ⋂p {ℓ₃ = ℓ₃} {ℓ₄} P)
⋂-OpClosed P isClosed f vs Q pQ = isClosed Q pQ f (map⇨v (λ v → v Q pQ) vs)

open SubAlg
⋂-SubAlg : ∀ {ℓ₃ ℓ₄} (P : IxPredicate ℓ₃ ℓ₄) →
             (∀ Q → P Q → OpClosed A (predicate ∘ Q)) →
             SubAlg {ℓ₃ = lsuc ℓ₁ ⊔ lsuc ℓ₂ ⊔ lsuc ℓ₃ ⊔ ℓ₄} A
⋂-SubAlg {ℓ₃} {ℓ₄} P isClosed = record
             { pr = ⋂p {ℓ₃} {ℓ₄} P
             ; opClosed = ⋂-OpClosed {ℓ₃} P isClosed
             }
⋂-SubAlg' : ∀ {ℓ₃ ℓ₄} → (P : Pred (SubAlg {ℓ₃ = ℓ₃} A) ℓ₄) → 
              SubAlg {ℓ₃ = lsuc ℓ₁ ⊔ lsuc ℓ₂ ⊔ lsuc ℓ₃ ⊔ ℓ₄} A
⋂-SubAlg' {ℓ₃} {ℓ₄} P = record
             { pr = pred
             ; opClosed = λ f vs Q pq → opClosed Q f (map⇨v (λ v → v Q pq) vs)
             }
     where pred : Predicate _
           pred s = record { predicate = λ x → ∀ Q → P Q → predicate (pr Q s) x
                           ; predWellDef = λ eq pres Q → predWellDef (pr Q s) eq ∘ pres Q
                           }


-- Algebra generated by a SetoidPredicate (not necessarily OpClosed).
<_>_ : ∀ {ℓ₃ ℓ₄} → (X : Predicate ℓ₃) → (P : Pred (SubAlg {ℓ₃ = ℓ₃} A) ℓ₄) →
         SubAlg {ℓ₃ = _} A
<_>_ {ℓ₃ = ℓ₃} {ℓ₄} X P = ⋂-SubAlg' λ Q → P Q × (X ⊆ₚ pr Q)

open import Data.List
-- Inductive definition.
Ops : ∀ Σ₁ → Set _
Ops Σ₁ = Σ[ ar ∈ List (sorts Σ₁) ] (Σ[ s ∈ sorts Σ₁ ] ops Σ₁ (ar ↦ s) )

Ops-on : ∀ Σ₁ → sorts Σ₁ → Set _
Ops-on Σ₁ s = Σ[ ar ∈ List (sorts Σ₁) ] (ops Σ₁ (ar ↦ s))

↾_,_ : ∀ {ℓ₃} → (X : Predicate ℓ₃) → (s : sorts Σ₁) → Set (ℓ₁ ⊔ ℓ₃)
↾ X , s = Σ[ a ∈ Setoid.Carrier (A ⟦ s ⟧ₛ) ] (predicate (X s) a)

Img : ∀ {ℓ₃} → (X : Predicate ℓ₃) → (s : sorts Σ₁) →
        Pred (Setoid.Carrier (A ⟦ s ⟧ₛ)) (ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃)
Img X s a = ∃ {A = Ops-on Σ₁ s} λ { (ar , f) →
                        Σ[ ts ∈ HVec (λ s' → ↾ X , s') ar ]
                          (a ≈ (A ⟦ f ⟧ₒ ⟨$⟩ mapV (λ _ → proj₁) ts)) } 
  where _≈_ : _
        _≈_ = Setoid._≈_ (A ⟦ s ⟧ₛ)

Img-WellDefined : ∀ {ℓ₃}→ (X : Predicate ℓ₃) → (s : sorts Σ₁) →
                  WellDef (A ⟦ s ⟧ₛ) (Img X s)
Img-WellDefined X s a≈b ((ar , f) , (ts , a≈f-ts)) = (ar , f) , (ts , trans (sym a≈b) a≈f-ts)
  where open Setoid (A ⟦ s ⟧ₛ)

Img-Pred : ∀ {ℓ₃} → (Predicate ℓ₃) → Predicate _
Img-Pred X s = record { predicate = Img X s
                      ; predWellDef = Img-WellDefined X s
                      }

E : ∀ {ℓ₃}  (X : Predicate ℓ₃) → Predicate (ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃)
E X s = ∪-SetoidPred (X s) (Img-Pred X s)

open import Data.Sum

E-inc : ∀ {ℓ₃} → (X : Predicate ℓ₃) → X ⊆ₚ E X
E-inc X s px = inj₁ px

E-mono : ∀ {ℓ₃ ℓ₄} → (X : Predicate ℓ₃) → (Y : Predicate ℓ₄) →
       X ⊆ₚ Y → E X ⊆ₚ E Y
E-mono X Y X⊆Y s (inj₁ px) = inj₁ (X⊆Y s px)
E-mono X Y X⊆Y s (inj₂ ((ar , f) , (ts , eq))) = (inj₂ ((ar , f) , ({!!} , {!!})))
  where open Setoid (A ⟦ s ⟧ₛ)

open import Data.Nat hiding (_^_;_⊔_)

l^ : Level → ℕ → Level
l^ ℓ zero = ℓ
l^ ℓ (suc n) = ℓ₁ ⊔ ℓ₂ ⊔ (l^ ℓ n)

E^ : ∀ (n : ℕ) → {ℓ₃ : Level} → (X : Predicate ℓ₃) → Predicate (l^ ℓ₃ n)
E^ zero X = X
E^ (suc n) {ℓ₃} X = E {ℓ₃ = l^ ℓ₃ n} (E^ n X)

E∞ : ∀ {ℓ₃} → (X : Predicate ℓ₃) → Predicate _
E∞ {ℓ₃} X s = record { predicate = {!!}
                ; predWellDef = {!!}
                }
