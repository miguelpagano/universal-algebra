\section{Equational Logic}
\label{sec:eqlog}

In this section we introduce the notion of (conditional) equational
theories and the corresponding notion of satisfiability of theories
by algebras. Moreover we formalize (conditional) equational logic as
presented by \cite{goguen2005specifying} and prove that
the deduction system is sound and complete.

\subsection{Satisfiability and provability}

\paragraph*{Equations} In the mono-sorted setting an equation is a pair
of terms where all the variables are assumed to be universally
quantified and an equational theory is a (finite) set of equations.
In a  multi-sorted setting both sides of an equation should be terms
of the same sort. Moreover we allow quasi-identities which we
write as conditional equations:
\[ t = t'\ \mathsf{if} \  t_1 = t'_1, \ldots, t_n = t'_n \enspace . \]

Let signature \AgdaBound{Σ} and \AgdaBound{X} be a family of variables
for \AgdaBound{Σ}. A conditional equation is modelled as a record
with fields for the conclusion and the conditions, consist of an
heterogeneous vector of sorted identities. We declare a constructor to
use the lighter notation
\AgdaInductiveConstructor{⋀}\AgdaSpace{}\AgdaBound{eq}\AgdaSpace{}
\AgdaInductiveConstructor{if}\AgdaSpace{}\AgdaBound{(ar, eqs)} instead of
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaField{eq}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{cond}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{\AgdaBound{(ar, eqs)}}
\AgdaSymbol{\}}

\begin{code}
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Equation}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Vars}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⋀\AgdaUnderscore{}if\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{eq}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Equ}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{s}\<%
\\
%
\>[4]\AgdaField{cond}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{∃}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{HVec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Equ}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{))}\<%
\\
%
\end{code}

\noindent A \emph{theory} over the signature $\Sigma$ is given by a
vector of conditional equations.
\begin{code}
  \>[0]\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Vars}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Arity}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{HVec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Equation}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ar}\<%
\\
%
\end{code}

We deviate from Goguen's and Lin's in that we assume that all the
equations of a theory share the same set of variables, while they
assume that each equation has its own set of quantified
variables. Clearly, this simplification is harmless; if we have a
theory where each equation has its own set of variables, we can take
the union of those sets as the common set. As stressed by
\cite{goguen-remarks-87}, quantifying equations is essential:
\begin{quote}
  [\ldots] the naive unsorted rules of deduction for equational logic
  (namely, reflexivity, symmetry, transitivity and substitutivity) are
  not sound when extended to the many-sorted case in the obvious way;
  [\ldots] adding variable declarations to these rules
  yields a rule set that is sound.
\end{quote}

\noindent Notice that we follow Goguen and Meseguer in that equations
are given explicitly over a set of variables. This, in turn, leads us
to define satisfiability as proposed by Huet and Oppen.

\paragraph*{Satisfiability} Let $\Sigma$ be a signature and
$\mathcal{A}$ be an algebra for $\Sigma$. We say that a conditional equation
$t = t'\ \mathsf{if}\ t_1 = t'_1,\ldots,t_n=t'_n$ is
\emph{satisfied} by $\mathcal{A}$ if for any
environment $\theta : X \to \mathcal{A}$, $⟦ t ⟧θ = ⟦ t' ⟧θ$, whenever
$⟦ t_i ⟧θ = ⟦ t'_i ⟧θ$ for $1 \leqslant i \leqslant n$. In order to
formalize satisfiability we first define when an environment models an
equation.

\begin{code}
  \>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{},\AgdaUnderscore{}⊨ₑ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}%
\>[12]\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Vars}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{θ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Equ}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{},\AgdaUnderscore{}⊨ₑ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{θ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≈ₑ}}\AgdaSpace{}%
\AgdaBound{t'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{θ}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{θ}\AgdaSpace{}%
\AgdaBound{t'}\<%
\end{code}

\noindent Using the point-wise extension of this relation we can write
directly the notion of satisfiability.

\begin{code}
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊨\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Vars}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Equation}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊨\AgdaUnderscore{}}}%
\>[423I]\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{⋀}}\AgdaSpace{}%
\AgdaBound{equ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{if}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{conds}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[423I]%
\>[4]\AgdaSymbol{(}\AgdaBound{θ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{,}}\AgdaSpace{}%
\AgdaBound{θ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨ₑ\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⇨v}}\AgdaSpace{}%
\AgdaBound{conds}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{,}}\AgdaSpace{}%
\AgdaBound{θ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨ₑ}}\AgdaSpace{}%
\AgdaBound{equ}\<%
\\
%
\end{code}

\noindent We say that $\mathcal{A}$ is a \emph{model} of the theory
$E$ if it satisfies each equation in $E$. As usual an equation is a
logical consequence of a theory, if every model of the theory
satisfies the equation.

\begin{code}
  \>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊨T\AgdaUnderscore{}}}\AgdaSpace{}%
  \AgdaSymbol{:}%
\>[454I]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSymbol{(}\AgdaBound{E}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨T}}\AgdaSpace{}%
\AgdaBound{E}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}∈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{E}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨}}\AgdaSpace{}%
\AgdaBound{e}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⊨All}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Arity}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{E}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSymbol{(}\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Equation}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{⊨All}\AgdaSpace{}%
\AgdaBound{E}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨T}}\AgdaSpace{}%
\AgdaBound{E}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨}}\AgdaSpace{}%
\AgdaBound{e}\<%
\\
%
\end{code}

\paragraph*{Provability} As noticed by \cite{huet-rewrite}, the
definition of a sound deduction system for multi-sorted equality logic
is more subtle than expected. We formalize the system presented of
\cite{goguen2005specifying}, shown in Fig.~\ref{fig:deduction}. The
first three rules are reflexivity, symmetry and transitivity; the
fourth rule, called substitution, allows to instantiate an axiom with
a substitution \AgdaBound{σ}, provided one has proofs for every condition
of the axiom;\footnote{In our formalization this rule is slightly less
  general because we assume all the equations are quantified over the
  same set of variables.}  finally, the last rule internalizes Leibniz
rule, for replacing equals by equals in subterms.  Notice that we can
only prove identities and not quasi-identities.
\begin{figure}[t]
  \centering
  \bottomAlignProof
  \AxiomC{}
  \UnaryInfC{$E \vdash \forall X,\, t = t$}
  \DisplayProof\hspace{2ex}
%
  \bottomAlignProof
  \AxiomC{$E \vdash \forall X,\, t_0 = t_1$}
  \UnaryInfC{$E \vdash \forall X,\, t_1 = t_0$}
  \DisplayProof \hspace{2ex}
% 
 \bottomAlignProof
 \AxiomC{$E \vdash \forall X,\, t_0 = t_1$}
  \AxiomC{$E \vdash \forall X,\, t_1 = t_2$}
  \BinaryInfC{$E \vdash \forall X,\, t_0 = t_2$}
  \DisplayProof
\\[6pt]
  \AxiomC{$\forall Y,\,t = t' \ \mathsf{if}\
      t_1=t'_1,\ldots, t_n=t'_n \in E$}
  \AxiomC{$E \vdash \forall X,\,\sigma(t_i) = \sigma(t'_i)$}
  \RightLabel{$\sigma \colon Y \rightarrow T_\Sigma(X)$}
  \BinaryInfC{$E \vdash \forall X,\, \sigma(t) = \sigma(t')$}
  \DisplayProof
\\[6pt]
  \AxiomC{$E \vdash \forall X,\, t_1 = t'_1$}
  \AxiomC{$\cdots$}
  \AxiomC{$E \vdash \forall X,\, t_n = t'_n$}
  \RightLabel{$f : [s_1,...,s_{n}] \Rightarrow_{\Sigma} s$}
  \TrinaryInfC{$E \vdash \forall X,\, f\,(t_1,\ldots,t_n) = f\,(t'_1,\ldots,t'_n)$}
  \DisplayProof\\[6pt]
  \caption{Deduction system}
  \label{fig:deduction}
\end{figure}
We define the relation of provability as an inductive type,
parameterized in the theory \AgdaBound{E}, and indexed by the conclusion of the
proof. For conciseness, we only show the constructor for transitivity:

\begin{code}
  \>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}}}%
\>[12]\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Arity}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{E}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Equation}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[4]\AgdaInductiveConstructor{ptrans}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSymbol{\}}%
\>[750I]\AgdaSymbol{\{}\AgdaBound{t₀}\AgdaSpace{}%
\AgdaBound{t₁}\AgdaSpace{}%
\AgdaBound{t₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{TΣ〔}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{〕}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[.][@{}l@{}]\<[750I]%
\>[19]\AgdaBound{E}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaBound{t₀}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaBound{t₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{E}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaBound{t₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaBound{t₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{E}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaBound{t₀}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaBound{t₂}\AgdaSymbol{)}\<%
\\
%
\end{code}

Let \AgdaBound{E} be a theory over a signature \AgdaBound{Σ}. It is
straightforward to define a setoid over
\AgdaFunction{TΣ}
\AgdaFunction{〔}\AgdaSpace{}\AgdaBound{X}\AgdaSpace{}\AgdaFunction{〕}
by letting \AgdaBound{t₁}\AgdaFunction{≈}\AgdaBound{t₂} if
\AgdaBound{E}\AgdaSpace{}\AgdaDatatype{⊢}\AgdaSpace{}\AgdaBound{t₁}\AgdaFunction{≈}\AgdaBound{t₂}; this
equivalence relation (thanks to the first three rules) is a congruence (because
of the last rule) over the term algebra. We can also use the facility provided
by the standard library to write proofs with several transitive steps more
nicely, as can be seen in the next example.

Soundness and completeness are proved as in the
mono-sorted case. For soundness one proceeds by induction on the
derivations; completeness is a consequence of the fact that the quotient of the
term algebra by provable equality is a model.
\begin{theorem}[Soundness and Completeness]
  $E \vdash t ≈ t'$ iff $E \models_{\Sigma} t ≈ t'$.
\end{theorem}
\noindent Let us remark that completeness does not imply that there is a
decidability algorithm for every theory; \ie this result gives no decision
procedure at all.

Let $E$ and $E'$ be two theories over the signature $\Sigma$. We say
that $E$ is \emph{stronger} than $E'$ if every axiom $e \in E'$ can be
deduced from $E$, written $E \vdash_{T}\, E'$.  Obviously if $E$
is stronger than $E'$, then any equation that can be deduced from $E'$
can also be deduced from $E$ and any model of $E$ is also a model of
$E'$.

\subsection{Equational classes are closed under IHSP}

Given a class $\mathcal{C}$ of algebras over some signature $\Sigma$
one interesting question is to know whether there it is equational,
ie.\ if there exists some theory $E$ such that the models of $E$ are
exactly those algebras in $\mathcal{C}$. Birkhoff showed that a
sufficient and necessary condition is to be closed under certain
class-operations.

$\mathcal{C}$ is closed under Isomorphism if
$\mathcal{B}\in \mathcal{C}$ whenever $\mathcal{A}\in \mathcal{C}$ and
$\mathcal{A}\simeq \mathcal{B}$. It is closed under products if for
any (arbitrary) family of algebras $\mathcal{A}_i\in \mathcal{C}$ its
direct product $\Pi_{i\in I} \mathcal{A}_i$ is also in
$\mathcal{C}$. Analogously, $\mathcal{C}$ is closed under subalgebras
if $\mathcal{B}\in \mathcal{C}$ for any subalgebra
$\mathcal{B}\leqslant \mathcal{A} \in \mathcal{C}$. Finally, it is
closed under homomorphic images if for any
$\mathcal{A} \in \mathcal{C}$ and epimorhism
$h : \mathcal{A} \to \mathcal{B}$ the homomorphic image of $A$ under
$h$ is also in $\mathcal{C}$. A class closed by these operations is
called a \emph{variety}. Birkhoff proved that every variety is the
class of models of some equational theory.

In our formalization we proved that the class of models of any
equational theory is closed under IHSP. The proof for I, S and P are
almost the same. In the module \AgdaModule{aux-sem} we proved a result
useful for all of them. From an environment for $\mathcal{B}$ and a
homomorphism from $\mathcal{B}$ to $\mathcal{A}$ we have an
environment for $\mathcal{A}$. Moreover the valuations in
$\mathcal{A}$ via the valuation in $\mathcal{B}$ and the homo, on the
one hand, and via the new environment should coincide by the universal
mapping property of the free algebra.

\newcommand{\sem}[2]{\llbracket #1 \rrbracket_{\mathcal{#2}}} In order
to prove, for example, that $\mathcal{C}$ is closed under subalgebras
we assume that $\mathcal{A}$ satisfies the equation and wants to prove
that $\mathcal{B}$ also satifies it; that is, we have to prove
$\sem{t}{B} = \sem{t'}{B}$. Since the equality in a subalgebra is
given by the equality on the underlying algebra of the first
projections, we need to show that $\pi₁ \sem{t}{A} = \pi_1\sem{t'}{A}$
Then we note that $\pi_1$ is the subembedding morphism from $\mathcal{B}$ to
$\mathcal{A}$, therefore we can use the previous result and the satisfaction
of $e$ by $\mathcal{A}$ to conclude that $\mathcal{B}$ also satisfies it.
\begin{code}
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{SubRespects⊨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SubAlgebra}\AgdaSpace{}%
\AgdaBound{B≤A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨}}\AgdaSpace{}%
\AgdaBound{e}\<%
\\
%
\>[2]\AgdaFunction{SubRespects⊨}\AgdaSpace{}%
\AgdaBound{θB}\AgdaSpace{}%
\AgdaBound{B⊨conds}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{proj₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧B}}%
\>[24]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⟦t⟧A≈H⟦t⟧B}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧A}}%
\>[24]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaBound{A⊨e}\AgdaSpace{}%
\AgdaFunction{θA}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⊨B*→⊨A*}\AgdaSpace{}%
\AgdaBound{B⊨conds}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧A}}%
\>[24]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaFunction{⟦t⟧A≈H⟦t⟧B}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[4]\AgdaField{proj₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧B}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∎}}\<%
\\
%
\>[4]\AgdaKeyword{where}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{aux-sem}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{SubAlgebra}\AgdaSpace{}%
\AgdaBound{B≤A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{θB}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sub-embedding}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B≤A}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{EqR}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Setoid}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\AgdaSymbol{)}\<%
\end{code}

The satisfaction of semi-equations are not preserved by homomorphic
images; we proved that the satisfaction of non-conditional equations
are preserved by homomorphic images. This result can be reduced to
proving that satisfaction is preserved under quotients, because the
homomorphic image is isomorphic to the source algebra quotiened by the
kernel of the homomorphism. In the following code fragment,
\AgdaFunction{equ} is the conditional equation corresponding to the
unconditional equation \AgdaBound{e}.

\begin{code}
\>[3]\AgdaFunction{imgH⊨e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{homImg}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{H}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨}}\AgdaSpace{}%
\AgdaFunction{equ}\<%
\\
%
\>[3]\AgdaFunction{imgH⊨e}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{IsoRespects⊨}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{A/φ⊨e}\AgdaSpace{}%
\AgdaBound{A⊨e}\AgdaSymbol{)}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaKeyword{where}%
\>[965I]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{IsoRespectSatisfaction}\AgdaSpace{}%
\AgdaFunction{equ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{I.iso-A/kerH}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{H}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[965I]%
\>[11]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{QuotientPreserveSatisfaction}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Kernel}\AgdaSpace{}%
\AgdaBound{H}\AgdaSymbol{)}\<%
\end{code}

% This forced us to introduce a
% notion of non-conditional equations and unconditional equational
% theory.

It is our immediate next goal to prove the converse, namely giving an equational
theory for any class closed by HSP. In the development branch of our
formalization we have some preliminaries definitions such as a more general
notion of free algebras, congruences generated by some relation, and more
results about sub-algebras.

One application that models of equational theories are closed under
IHSP is to prove that some theories are not equational
axiomatizable. We proved that fields are not equational because they
are not closed under products (of course, the problem is that an
equational lacks negations). Our approach to proving this, was to
introduce a shallow notion of fields (\ie we do not have a syntactic
representation of fields, but we model them as setoids with operations
satisfying the axioms) and assume that there is an equational theory
modelling them. Thus, we can easily turn $\mathit{Bool}$ into a field with
the xor and conjunction operations that satisfy the equational theory,
then the self-product must satisfy the equational using that it is closed under
IHSP (particularly Products), however as we have noticed the product of fields
is not a field; for this particular field, clearly not all pair
$(b,b') \neq 0_{\mathit{Bool} \times \mathit{Bool}}$
satisfy $(b,b') \wedge (b,b')^{-1} = 1_{\mathit{Bool} \times \mathit{Bool}}$ where
the operations apply component-wise
\footnote{$1_{\mathit{Bool} \times \mathit{Bool}} = (true, true)$,\,
  $0_{\mathit{Bool} \times \mathit{Bool}} = (false, false)$ and $b^{-1} = b$}.
% COMPLETAR.
% Decir que tomar a≠b como ¬(a=b) se llama tight apartness

In the standard library there are shallow definitions of several
algebraic structures (from magmas up to commutative rings) but it
lacks the product bi-functor. We have defined an interface between
models of the deep embeddings of those structures (in our library)
with those of the standard library. In this way we get by closedness
of products a product of shallow monoids.

\subsection{A theory for Boolean Algebras }\label{sec:eqlog-theory-ol}
In this section we outline
how to formalize an equational theory and illustrate each step by
showing snippets of the formalization of a Boolean Theory presented by
\cite{DBLP:conf/RelMiCS/RochaM08}.\footnote{The full code is available
  in the file \nolinkurl{Examples/EqBool.agda} of the repository.}

\paragraph*{Define the signature}
\label{sec:define-signature} describing the language, and choose
  a family of sets for the variables. It helps if one also introduce
  an abbreviation for terms over the signature extended with
  variables.

  \begin{code}
    \>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Σops₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{t₁} \AgdaInductiveConstructor{f₁}% %
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Σops₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{neg₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Σops₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{and₁} \AgdaInductiveConstructor{or₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Σops₁}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Σbool₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Signature}\<%
\\
\>[0]\AgdaFunction{Σbool₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Σops₁}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[0]\AgdaFunction{ΣVars₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Vars}\AgdaSpace{}%
\AgdaFunction{Σbool₁}\<%
\\
%
\>[0]\AgdaFunction{ΣVars₁}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[0]\AgdaFunction{Form₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
%
\>[0]\AgdaFunction{Form₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Terms}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\<%
\\
\end{code}
  
\paragraph*{Introduce smart-constructors}
\label{sec:intr-smart-constr}
  for terms of the extended
  signature with variables to ease writing the axioms and proving
  theorems. Usually one has a smart-constructor for each operation and
  one per variable that is used in the axioms or the theorems.

\begin{code}
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∧\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Form₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Form₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Form₁}\<%
\\
%
\>[4]\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{term}\AgdaSpace{}%
\AgdaInductiveConstructor{and₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨⟨}}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩⟩}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{¬}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Form₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Form₁}\<%
\\
%
\>[4]\AgdaFunction{¬}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{term}\AgdaSpace{}%
\AgdaInductiveConstructor{neg₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟪}}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟫}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{p}\AgdaSymbol{,}\AgdaFunction{q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Form₁}\<%
\\
%
\>[4]\AgdaFunction{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{term}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{⟨⟩}\<%
\\
\>[4]\AgdaFunction{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{term}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{⟨⟩}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{true}\AgdaSymbol{,}\AgdaFunction{false}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Form₁}\<%
\\
%
\>[4]\AgdaFunction{true}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{term}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{t₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{⟨⟩}\<%
\\
\>[4]\AgdaFunction{false}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{term}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{f₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{⟨⟩}\<%
\\
%
\end{code}

\paragraph*{Define the equational theory}
\label{sec:define-equat-theory}

 by specifying one equation for
  each axiom and collect them in a theory; here one can appreciate the
  convenience of the smart-constructors. Here we only show two of the
  twelve axioms of the theory \AgdaBound{Tbool}. If one will prove theorems
  of the theory, then it is also convenient to define pattern-synonyms
  for the proofs that each axiom is in the theory.

  \begin{code}
    \>[0]\AgdaFunction{commAnd}\AgdaSpace{}%
    \AgdaSymbol{:}\AgdaSpace{}%
    \AgdaFunction{Eq₁}\<%
    \\
    %
    \>[0]\AgdaFunction{commAnd}\AgdaSpace{}%
    \AgdaSymbol{=}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
    \AgdaFunction{p}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
    \AgdaFunction{q}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
    \AgdaSymbol{(}\AgdaFunction{q}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
    \AgdaFunction{p}\AgdaSymbol{)}\<%
    \\
    %
    \\[\AgdaEmptyExtraSkip]%
    \>[2]\AgdaFunction{defF}\AgdaSpace{}%
    \AgdaSymbol{:}\AgdaSpace{}%
    \AgdaFunction{Eq₁}\<%
    \\
    %
    \>[2]\AgdaFunction{defF}\AgdaSpace{}%
    \AgdaSymbol{=}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
    \AgdaFunction{p}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
    \AgdaSymbol{(}\AgdaFunction{¬}\AgdaSpace{}%
    \AgdaFunction{p}\AgdaSymbol{)}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
    \AgdaFunction{false}\<%
    \\%
    \\[\AgdaEmptyExtraSkip]%
    \>[2]\AgdaFunction{Tbool₁}\AgdaSpace{}%
    \AgdaSymbol{:}\AgdaSpace{}%
    \AgdaFunction{Theory}\AgdaSpace{}%
    \AgdaFunction{Vars}\AgdaSpace{}%
    \AgdaSymbol{(}\AgdaFunction{replicate}\AgdaSpace{}%
    \AgdaNumber{12}\AgdaSpace{}%
    \AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
    \\
    %
    \>[2]\AgdaFunction{Tbool₁}\AgdaSpace{}%
    \AgdaSymbol{=}\AgdaSpace{}%
    \AgdaSymbol{⟨}\AgdaSpace{}\AgdaFunction{commAnd}\AgdaSpace{}%
    \AgdaSymbol{,}\AgdaSpace{}%
    \AgdaFunction{defF}\AgdaSpace{}%
    \AgdaSymbol{,}\AgdaSpace{}%
    $\ldots$
    \AgdaSymbol{⟩}
    \<%
    \\%
    \\[\AgdaEmptyExtraSkip]%
    \>[2]\AgdaKeyword{pattern}\AgdaSpace{}%
    \AgdaInductiveConstructor{commAndAx}\AgdaSpace{}%
    \AgdaSymbol{=}\AgdaSpace{}%
    \AgdaInductiveConstructor{here}\<%
    \\
    %
    \>[2]\AgdaKeyword{pattern}\AgdaSpace{}%
    \AgdaInductiveConstructor{defFAx}\AgdaSpace{}%
    \AgdaSymbol{=}\AgdaSpace{}%
    \AgdaInductiveConstructor{there}\AgdaSpace{}%
    \AgdaInductiveConstructor{here}\<%
  \end{code}

\paragraph*{Prove theorems}
  using the axioms of the theory just defined.
  If a proof uses transitivity, one can use the equational reasoning
  idiom provided by the standard library of Agda:

  \begin{code}
    \>[2]\AgdaFunction{prop}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[8]\AgdaFunction{Tbool₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaFunction{¬}\AgdaSpace{}%
\AgdaFunction{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaFunction{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaFunction{false}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{prop}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[503I]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[503I][@{}l@{\AgdaIndent{0}}]%
\>[9]\AgdaFunction{¬}\AgdaSpace{}%
\AgdaFunction{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaFunction{p}\<%
\\
%
\>[9]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{psubst}\AgdaSpace{}%
\AgdaInductiveConstructor{axComm∧}\AgdaSpace{}%
\AgdaFunction{σ}\AgdaSpace{}%
\AgdaInductiveConstructor{⇨v⟨⟩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[9]\AgdaFunction{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaFunction{¬}\AgdaSpace{}%
\AgdaFunction{p}\<%
\\
%
\>[9]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{psubst}\AgdaSpace{}%
\AgdaInductiveConstructor{axDefF}\AgdaSpace{}%
\AgdaFunction{idSubst}\AgdaSpace{}%
\AgdaInductiveConstructor{⇨v⟨⟩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[9]\AgdaFunction{false}\<%
\\
\>[.][@{}l@{}]\<[503I]%
\>[7]\AgdaOperator{\AgdaFunction{∎}}\<%
  \end{code}

\noindent In the justification steps of this proof we use the
substitution rule. The relevant actions of the substitution \AgdaFunction{σ} are
\AgdaFunction{σ}\AgdaSpace{}\AgdaFunction{p}\AgdaSpace{}\AgdaSymbol{=}
\AgdaFunction{¬}\AgdaSpace{}\AgdaFunction{p} and
\AgdaFunction{σ}\AgdaSpace{}\AgdaFunction{q}\AgdaSpace{}\AgdaSymbol{=}
\AgdaFunction{p}.

%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "univ-alg.tex"  ***
%%% End: ***
