-- Universal Algebra Library
--
-- Constructions and Properties about congruences
--

open import UnivAlgebra
open import Level renaming (zero to lzero ; suc to lsuc)
module Congruences (Σ : Signature) {ℓ₁ ℓ₂ : Level} (A : Algebra {ℓ₁} {ℓ₂} Σ) where

open import Data.List hiding (map)
open import Data.Product hiding (map;Σ)
open import Data.Unit.Polymorphic
open import Function as F hiding (Surjective;Bijective)
open import Function.Equality as FE renaming (_∘_ to _∘ₛ_) hiding (setoid)
open import Function.Bijection renaming (_∘_ to _∘b_)
open import Function.Surjection hiding (_∘_)
open import Relation.Binary
import Relation.Binary.Construct.Always as A
open import Relation.Unary hiding (_⊆_;_⇒_)
open import Relation.Unary renaming (_⊆_ to _⊆r_) hiding (_⇒_)

open import Setoids
open import Morphisms
open import HeterogeneousVec

open Hom
open Homo
open Setoid
open Congruence

IRel : ∀ ℓ₃ → Set (ℓ₁ ⊔ lsuc ℓ₃)
IRel ℓ₃ = {s : sorts Σ} → Rel (∥ A ⟦ s ⟧ₛ ∥) ℓ₃

_⇒ₛ_ : ∀ {ℓ₃ ℓ₄ : Level} (R : IRel ℓ₃) → (S : IRel ℓ₄) → Set (ℓ₁ ⊔ ℓ₃ ⊔ ℓ₄)
R ⇒ₛ S = ∀ s → R {s} ⇒ S {s}

⇒-refl : ∀ {ℓ₃ : Level} (R : IRel ℓ₃) → R ⇒ₛ R
⇒-refl R s a = a

⇒-trans : ∀ {ℓ₃ ℓ₄ ℓ₅ : Level} {R : IRel ℓ₃} {S : IRel ℓ₄} {T : IRel ℓ₅} →
          R ⇒ₛ S → S ⇒ₛ T → R ⇒ₛ T
⇒-trans R≤S S≤T s ab = S≤T s (R≤S s ab)

-- The Intersection of an OpClosed family of predicates is OpClosed.
⋂-cong : ∀ {ℓ₃ ℓ₄} → Pred (Congruence {ℓ₃ =  ℓ₃} A) ℓ₄ → Congruence {ℓ₃ = ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃ ⊔ ℓ₄} A
⋂-cong P = record
  { rel = λ {s} a b → ∀ C → P C → rel C {s} a b
  ; welldef = λ s a b C PC → welldef C s a (b C PC)
  ; cequiv = λ s → record
                      { refl = λ C PC → refl (cequiv C s)
                      ; sym = λ x C PC → sym (cequiv C s) (x C PC)
                      ; trans = λ x y C PC → trans (cequiv C s) (x C PC) (y C PC)
                      }
  ; csubst = λ f rs C PC → csubst C f (map∼v (λ r → r C PC) rs)
  }
  where open IsEquivalence


≡-Generated : ∀ {ℓ₃ ℓ₄ : Level} (R : IRel ℓ₃) →
  Congruence {ℓ₃ = ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₄ ⊔ (ℓ₁ ⊔ ℓ₃ ⊔ ℓ₄)} A
≡-Generated {ℓ₄ = ℓ₄} R = ⋂-cong {ℓ₃ = ℓ₄} (λ c → R ⇒ₛ rel c)

≡c-Generated : ∀ {ℓ₃ ℓ₄ : Level} (φ : Congruence {ℓ₃ = ℓ₃} A) →
  Congruence {ℓ₃ = ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₄ ⊔ (ℓ₁ ⊔ ℓ₃ ⊔ ℓ₄)} A
≡c-Generated  {ℓ₄ = ℓ₄} φ = ≡-Generated {ℓ₄ = ℓ₄} (rel φ)

≡-monotone : ∀ {ℓ₃ ℓ₄ ℓ₅ : Level} (R : IRel ℓ₃) → (S : IRel ℓ₄) → (R ⇒ₛ S) →
              rel (≡-Generated {ℓ₄ = ℓ₅} R) ⇒ₛ rel (≡-Generated {ℓ₄ = ℓ₅} S)
≡-monotone R S R≤S s ab C S≤C = ab C (⇒-trans R≤S S≤C)

≡-elim : ∀ {ℓ₃ ℓ₄ : Level} (R : IRel ℓ₃) → (φ : Congruence {ℓ₃ = ℓ₄} A) →
          (R ⇒ₛ rel φ) → rel (≡-Generated {ℓ₄ = ℓ₄} R) ⇒ₛ rel φ
≡-elim R φ R≤φ s ab = ab φ R≤φ


-- The congruent closure generated by a relation.
data I∞ {ℓ₃} (R : IRel ℓ₃) : IRel (lsuc ℓ₃ ⊔ ℓ₁ ⊔ ℓ₂) where
  IR : ∀ s {a} {b} → R {s} a b → I∞ R {s} a b
  IRefl : ∀ s {a} {b} → _≈_ (A ⟦ s ⟧ₛ) a b → I∞ R {s} a b
  ISym : ∀ s {a} {b} → I∞ R {s} a b → I∞ R {s} b a
  ITran : ∀ s {a} {b} {c} → I∞ R {s} a b → I∞ R {s} b c → I∞ R {s} a c
  IQ : ∀ {ar} s {f : ops Σ (ar ↦ s)} {as} {bs} →
        _∼v_ {R = I∞ R} as bs → I∞ R {s} (A ⟦ f ⟧ₒ ⟨$⟩ as) (A ⟦ f ⟧ₒ ⟨$⟩ bs)

I∞-cong : ∀ {ℓ₃} (R : IRel ℓ₃) → Congruence A
I∞-cong R = record
  { rel = I∞ R
  ; welldef = λ { s (a≈c , b≈d) a~b
              → ITran s (IRefl s (sym (A ⟦ s ⟧ₛ) a≈c)) (ITran s a~b (IRefl s b≈d)) }
  ; cequiv = λ s → record
                     { refl = IRefl s (refl (A ⟦ s ⟧ₛ))
                     ; sym = ISym s
                     ; trans = ITran s
                     }
  ; csubst = λ {_ }{s} f rs → IQ s {f = f} rs
  }


I∞⇒≡-Gen : ∀ {ℓ₃ ℓ₄} (R : IRel ℓ₃) → rel (I∞-cong R) ⇒ₛ rel (≡-Generated {ℓ₄ = ℓ₄} R)
I∞⇒≡-Gen* : ∀ {ℓ₃ ℓ₄} {ar}  (R : IRel ℓ₃) → {as bs : HVec _ ar} →
             _∼v_ {R = rel (I∞-cong R) } as bs →
             _∼v_ {R = rel (≡-Generated {ℓ₄ = ℓ₄} R)} as bs
I∞⇒≡-Gen* {ar = .[]} R ∼⟨⟩ = ∼⟨⟩
I∞⇒≡-Gen* {ar = (s ∷ _)} R (∼▹ x as~bs) = ∼▹ (I∞⇒≡-Gen R s x) (I∞⇒≡-Gen* R as~bs)
I∞⇒≡-Gen R s (IR .s x) C R≤C = R≤C s x
I∞⇒≡-Gen {ℓ₄ = ℓ₄} R s (IRefl .s {a} {b} a≈b) C R≤C =
                   wdef s {b , b } {a , b} (sym (A ⟦ s ⟧ₛ) a≈b , refl (A ⟦ s ⟧ₛ) {b}) (ref {b})
  where wdef = welldef C
        open IsEquivalence (cequiv C s) renaming (sym to sy;refl to ref)
I∞⇒≡-Gen {ℓ₄ = ℓ₄} R s (ISym .s ab) = sy (I∞⇒≡-Gen R s ab)
  where open IsEquivalence (cequiv (≡-Generated {ℓ₄ = ℓ₄} R) s) renaming (sym to sy)
I∞⇒≡-Gen {ℓ₄ = ℓ₄} R s (ITran .s ab bc) = tr (I∞⇒≡-Gen R s ab) (I∞⇒≡-Gen R s bc)
  where open IsEquivalence (cequiv (≡-Generated {ℓ₄ = ℓ₄} R) s) renaming (trans to tr)
I∞⇒≡-Gen R s (IQ .s {f = f} ab) C R≤C = csubst C f (map∼v (λ x → x C R≤C) (I∞⇒≡-Gen* R ab))

≡-Gen⇒I∞ : ∀ {ℓ₃} (R : IRel ℓ₃) → rel (≡-Generated {ℓ₄ = (ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)} R) ⇒ₛ rel (I∞-cong R)
≡-Gen⇒I∞ R s ab = ≡-elim R (I∞-cong R) IR s ab


Δ : Congruence A
Δ = record
  { rel = λ {s} → _≈_ (A ⟦ s ⟧ₛ)
  ; welldef = λ { s (a≈c , b≈d) a≈b →
              trans (A ⟦ s ⟧ₛ) (sym (A ⟦ s ⟧ₛ) a≈c)
                              (trans (A ⟦ s ⟧ₛ) a≈b b≈d) }
  ; cequiv = λ s → isEquivalence (A ⟦ s ⟧ₛ)
  ; csubst = λ f as≈bs → cong (A ⟦ f ⟧ₒ) as≈bs
  }

∇ : ∀ ℓ → Congruence {ℓ₃ = ℓ} A
∇ ℓ = record
  { rel = λ {s} → A.Always {A = ∥ A ⟦ s ⟧ₛ ∥ }
  ; welldef = λ _ _ _ → tt
  ; cequiv = λ s → A.isEquivalence ∥ A ⟦ s ⟧ₛ ∥ ℓ
  ; csubst = λ _ _ → tt
  }

IsSeparating : ∀ {ℓ₃ ℓ₄} → Pred (Congruence {ℓ₃ =  ℓ₃} A) ℓ₄ → Set _
IsSeparating P = ∀ C → P C → rel C ⇒ₛ rel Δ
