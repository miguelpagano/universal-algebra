\section{Monoids and Groups: an example of equational theories}
\label{sec:extheories}

In this section we present a pleasant method, using parameterised modules, for
defining equational theories that depends in a cascade-way in which every layer
increase complexity, how is the case with algebraic structures like monoids,
groups, rings, etc.

\subsection{Naive formalization}
%\subsection{Monoids}

Previous to use parameterised modules, we can extend the example presented in
the Sec.~\ref{sec:univ-alg} to exemplify the main limitation of directly using a
data type to define a theory. In this prior section we define the data type
\AgdaDatatype{monoid-op} as an example to define the monoid signature
\AgdaFunction{monoid-sig}. It is straightforward to formalize the theory of
monoids (\ie an algebraic structure with a single associative binary operation
and an identity element) by applying the outline presented in
\ref{sec:eqlog-theory-ol}: first, given some family of sets of variables, say
\AgdaFunction{X}\AgdaSpace{} \AgdaSymbol{:}\AgdaSpace{} \AgdaFunction{Vars}
\AgdaFunction{monoid{-}sig}, we define \AgdaFunction{Term}\AgdaSpace{}
\AgdaSymbol{=}\AgdaSpace{} \AgdaFunction{T} \AgdaSpace{}
\AgdaFunction{monoid{-}sig}\AgdaSpace{}
\AgdaSymbol{〔}\AgdaFunction{X}\AgdaSymbol{〕}, the set of terms over the
extended signature; second, we introduce the obvious smart-constructors
\AgdaUnderscore{}\AgdaOperator{\AgdaFunction{∘}}\AgdaUnderscore{} for the
binary operation, and \AgdaFunction{u} for the identity element; finally we
write the associativity and identity element axioms.

\begin{code}
\>[4]\AgdaFunction{assocOp}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{z}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{z}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{unitLeft}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaFunction{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaFunction{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{unitRight}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaFunction{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{MonTheory}%
\>[15]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaFunction{X}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{MonTheory}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{assocOp}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaFunction{unitLeft}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaFunction{unitRight}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaInductiveConstructor{⟨⟩}\<%
\end{code}

\noindent
Extending this theory of monoids to the theory of commutative monoids (also
called, abelian monoids) is pretty straightforward. There is no need to extend
the signature with new constructors, neither new smart-constructors. We only
need to define the commutative axiom; thus we simply define the theory of
commutative monoids as the previous theory plus this axiom.

\begin{code}
\noindent \>[0]\AgdaFunction{commOp}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{x}\AgdaSymbol{)}\<%
\\%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{CommMonTheory}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaFunction{X}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\%
\>[0]\AgdaFunction{CommMonTheory}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{commOp}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaFunction{MonTheory}\<%
\\
\end{code}

\noindent
Other reasonable extension is to formalize the theory of groups using the monoid
theory. A desirable way for doing this is to use the fact that a group (a
an algebraic structure with a single binary operation, an unary operation
and an identity element) is a monoid for the binary operation and the identity
element, plus some invertibility axioms. This time we have to extend the
signature with the new constructor for the unary operation. The simplest way
is to define the data type and the corresponding signature:

\begin{code}
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{group{-}op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaInductiveConstructor{mops}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}
\AgdaDatatype{monoid{-}op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}
\AgdaSymbol{)}
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{group{-}op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}
\<%
\\
%
\>[3]\AgdaInductiveConstructor{\AgdaUnderscore{}⁻¹}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{group{-}op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\\
\>[0]\AgdaFunction{group{-}sig}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Signature}\<%
\\
\>[0]\AgdaFunction{group{-}sig}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{group{-}op}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

As before we define new smart-constructor for the unary operation and the
invertibility axioms; \AgdaFunction{invElemRight}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⁻}}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaFunction{u} and
\AgdaFunction{invElemLeft}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⁻}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaFunction{u}. Sadly we can't construct the group theory, say
\AgdaFunction{GrpTheory}, by appending these axioms to \AgdaFunction{MonTheory}
(as we did for example with \AgdaFunction{CommMonTheory}). The problem is that
behind all this naive extension the signatures of the invertibility axioms and
monoid theory axioms are different. Obviously there are ways of solving this
problem and possible others that can appear, but we think using parameterised
modules is a more clean approach.

\subsection{Using parameterised modules}
%\subsection{Groups}

The use of parameterised modules helps us to generalize concrete definitions
that live in the module, particularly our approach it is to generalize the
concrete data type that define the operations field in the signature of a given
algebraic structure. Thus, we refactor the previous formalizations generalizing
the data types that define operations and also the corresponding constructors of
these operations; notice that the type \AgdaBound{monoid{-}op} is valid only if
it has at least two constructors with the correct type. Also notice that
we don't generalize the set of sorts, but it would be necessary if we pretend
to formalize for example Modules.

\begin{code}
\>[0]\AgdaKeyword{module}%
\>[70I]\AgdaModule{Monoid}%
\>[71I]\AgdaSymbol{\{}\AgdaBound{monoid{-}op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[71I]%
\>[14]\AgdaSymbol{(}\AgdaBound{e}%
\>[22]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{monoid{-}op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{))}\<%
\\
%
\>[14]\AgdaSymbol{(}\AgdaBound{∘}%
\>[21]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{monoid{-}op}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{Σ-mon}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Signature}\<%
\\%
\>[2]\AgdaFunction{Σ-mon}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{monoid{-}op}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

\noindent The rest of the module is straightforward, we define a submodule
\AgdaModule{Theory} where all the definitions related to the theory are defined;
smart-constructors, axioms and the theory.

\begin{code}
  \>[0][@{}l@{\AgdaIndent{0}}]%
  \>[2]\AgdaKeyword{module}\AgdaSpace{}%
  \AgdaModule{Theory}\AgdaSpace{}%
  \AgdaKeyword{where}
  \\
  \>[2][@{}l@{\AgdaIndent{0}}]%
  \>[4]
  $\vdots$
  \\
  \>[4]\AgdaFunction{MonTheory}\AgdaSpace{}%
  \AgdaSymbol{=}\AgdaSpace{}%
  \AgdaFunction{assocOp}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
  \AgdaFunction{unitLeft}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
  \AgdaFunction{unitRight}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
  \AgdaInductiveConstructor{⟨⟩}
  \<%
\end{code}

\noindent
Following the same strategy we define the group theory with a parameterised
modules with the data type that define the operations and the corresponding
constructors for the binary operation, the unary operation and the identity
element. Notice that using the previous module definition we can instantiate
the Monoid module with the data type \AgdaBound{group-op}, then it is a monoid
with the constructors \AgdaBound{e} and \AgdaBound{∘}; thus we have the axioms of
\AgdaFunction{MonTheory} in the correct signature, and we can append the
invertibility axioms.

\begin{code}
  \>[0]\AgdaKeyword{module}%
  \>[64I]\AgdaModule{Group}%
  \>[65I]\AgdaSymbol{\{}\AgdaBound{group-op}\AgdaSpace{}%
  \AgdaSymbol{:}\AgdaSpace{}%
  \AgdaDatatype{List}\AgdaSpace{}%
  \AgdaRecord{⊤}\AgdaSpace{}%
  \AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
  \AgdaRecord{⊤}\AgdaSpace{}%
  \AgdaSymbol{→}\AgdaSpace{}%
  \AgdaPrimitiveType{Set}\AgdaSymbol{\}}\<%
  \\
  \>[.][@{}l@{}]\<[65I]%
  \>[13]\AgdaSymbol{(}\AgdaBound{e}%
  \>[21]\AgdaSymbol{:}\AgdaSpace{}%
  \AgdaBound{group-op}\AgdaSpace{}%
  \AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
  \AgdaInductiveConstructor{tt}\AgdaSymbol{))}\<%
  \\%
  \>[13]\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⁻¹}}%
  \>[21]\AgdaSymbol{:}\AgdaSpace{}%
  \AgdaBound{group-op}\AgdaSpace{}%
  \AgdaSymbol{(}\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
    \AgdaInductiveConstructor{tt}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
  \AgdaInductiveConstructor{tt}\AgdaSymbol{))}\<%
  \\%
  \>[13]\AgdaSymbol{(}\AgdaBound{∘}%
  \>[20]\AgdaSymbol{:}\AgdaSpace{}%
  \AgdaBound{group-op}\AgdaSpace{}%
  \AgdaSymbol{((}\AgdaInductiveConstructor{tt}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
  \AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
    \AgdaInductiveConstructor{tt}\AgdaSpace{}%
    \AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
  \AgdaInductiveConstructor{tt}\AgdaSymbol{))}\<%
  \\
  \>[.][@{}l@{}]\<[64I]%
  \>[7]\AgdaKeyword{where}\<%
  \\
  \>[0][@{}l@{\AgdaIndent{0}}]%
  \>[2]\AgdaKeyword{open}\AgdaSpace{}%
  \AgdaKeyword{module}\AgdaSpace{}%
  \AgdaModule{M}\AgdaSpace{}%
  \AgdaSymbol{=}\AgdaSpace{}%
  \AgdaModule{Monoid}\AgdaSpace{}%
  \AgdaSymbol{\{}\AgdaBound{group-op}\AgdaSymbol{\}}\AgdaSpace{}%
  \AgdaBound{e}\AgdaSpace{}%
  \AgdaBound{∘}\<%
  \\
  %
  \\[\AgdaEmptyExtraSkip]%
  %
  \>[2]\AgdaFunction{Σ-grp}\AgdaSpace{}%
  \AgdaSymbol{:}\AgdaSpace{}%
  \AgdaRecord{Signature}\<%
  \\
  %
  \>[2]\AgdaFunction{Σ-grp}\AgdaSpace{}%
  \AgdaSymbol{=}\AgdaSpace{}%
  \AgdaKeyword{record}\AgdaSpace{}%
  \AgdaSymbol{\{}\AgdaSpace{}%
  \AgdaField{sorts}\AgdaSpace{}%
  \AgdaSymbol{=}\AgdaSpace{}%
  \AgdaRecord{⊤}\AgdaSpace{}%
  \AgdaSymbol{;}\AgdaSpace{}%
  \AgdaField{ops}\AgdaSpace{}%
  \AgdaSymbol{=}\AgdaSpace{}%
  \AgdaBound{group-op}\AgdaSpace{}%
  \AgdaSymbol{\}}\<%
  \\%
  \\[\AgdaEmptyExtraSkip]%
  %
  \>[2]\AgdaKeyword{module}\AgdaSpace{}%
  \AgdaModule{GrpTheory}\AgdaSpace{}%
  \AgdaKeyword{where}\<%
  \\
  \>[2][@{}l@{\AgdaIndent{0}}]%
  \>[4]\AgdaKeyword{open}\AgdaSpace{}%
  \AgdaModule{M.Theory}\AgdaSpace{}%
  \\
  \>[4]$\vdots$
  \\
  \>[4]\AgdaFunction{GrpTheory}\AgdaSpace{}%
  \AgdaSymbol{=}\AgdaSpace{}%
  \AgdaFunction{invElemRight}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
  \AgdaFunction{invElemLeft}\AgdaSpace{}%
  \AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
  \AgdaFunction{MonTheory}\<%
  \<%
\end{code}


\noindent
Using this approach we formalize Monoids, Commutative Monoids, Groups,
Commutative Groups, Semirings, Ring and Commutative Rings.
