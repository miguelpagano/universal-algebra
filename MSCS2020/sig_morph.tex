\section{Morphisms between signatures}
\label{sec:trans}
In this section we explain our formalization of morphisms between
signatures; this notion is interesting because it provides a
conceptual understanding of syntactic translations. After pointing to
some related works, we motivate the usefulness of this notion by
showing a relatively simple example: how to interpret the Boolean
theory of the previous section in the propositional calculus of
Dijkstra and Scholten.\footnote{\cite{rocha-2007}
  study more thoroughly Boolean theories and their morphisms.}

The concept of morphism between signatures is related with the
interpretability of similarity types in universal algebra
(cf.~\cite{garcia-84}), and has an extensive literature:
~\cite{fujiwara-1959} introduced this notion as
\textit{mappings between algebraic systems},
\cite{janssen-98}, following the ADJ group, called it a
\textit{polynomial derivor} and \cite{mossakowski-15}
referred to it as a \textit{derived signature morphism}, a generalization
of the more restricted \textit{signature morphisms} in the theory of
institutions \citep{goguen-92}.

Let us analyze how to translate the Boolean theory of the previous
section to the propositional calculus of \cite{dijkstra-scholten},
whose only non-constant operations are equivalence and disjunction.
\begin{code}
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Σops₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{t₂}\AgdaSpace{}%
\AgdaInductiveConstructor{f₂}%
\>[14]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Σops₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↦}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{or₂}\AgdaSpace{}%
\AgdaInductiveConstructor{equiv₂}%
\>[14]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Σops₂}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↦}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Σbool₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Signature}\<%
\\
\>[0]\AgdaFunction{Σbool₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Σops₂}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

It is clear that one can translate recursively any term over
\AgdaFunction{bool-sig} to a term in \AgdaFunction{bool-sig'}
preserving its semantics. % Tiene sentido decir cómo?
An alternative and more general way is to specify how to translate
each operation in \AgdaFunction{bool-sig} using operations in
\AgdaFunction{bool-sig'}. In this way, any
\AgdaFunction{bool-sig'}-algebra can be seen as a
\AgdaFunction{bool-sig}-algebra: a
\AgdaFunction{bool-sig}-operation \AgdaBound{f} is interpreted as
the semantics of the translation of \AgdaBound{f}. In particular,
the translation of formulas is recovered as the initial
homomorphism between
\AgdaFunction{∣T∣}\AgdaSpace{}\AgdaFunction{bool-sig} and the
transformation of
\AgdaFunction{∣T∣}\AgdaSpace{}\AgdaFunction{bool-sig'}. In this
section we formalize the concepts of \emph{derived signature
  morphism} and \emph{reduct algebra} as introduced, for example,
by \cite{sannella2012foundations}.

\subsection{Derived signature morphism}

Although the disjunction from \AgdaFunction{bool-sig} can be directly mapped to its
namesake in \AgdaFunction{bool-sig'}, there is no unary operation in \AgdaFunction{bool-sig'} to
translate the negation. In fact, we should be able to translate an
operation as a combination of operations in \codigo{bool-sig'} and
also refer to the arguments of the original operation.
\newcommand{\sdash}[1]{\vdash}

We introduce the notion of \emph{formal terms} which are formal
composition of projections and operations. We introduce a type
system, shown in Fig.~\ref{fig:formalterms}, ensuring the
well-formedness of these terms: the contexts are arities, \ie lists of
sorts, and identifiers are pointers (like de Bruijn indices).
\begin{figure}[t]
  \centering
    \bottomAlignProof
    \AxiomC{}
    \RightLabel{\textsc{(prj)}}
    \UnaryInfC{$[s_{1},\ldots,s_{n}] \sdash{\Sigma} \sharp i : s_i$}
  \DisplayProof
% 
  \bottomAlignProof
  \insertBetweenHyps{\hskip -4pt}
  \AxiomC{$f : [s_1,...,s_{n}] \Rightarrow_{\Sigma} s$}
  \AxiomC{$\mathit{ar} \sdash{\Sigma} t_1 : s_1$}
  \AxiomC{$\cdots$}
  \AxiomC{$\mathit{ar} \sdash{\Sigma} t_n : s_n$}
  \RightLabel{\textsc{(op)}}
  \QuaternaryInfC{$\mathit{ar} \sdash{\Sigma} f\,(t_1,...,t_{n}) : s$}
  \DisplayProof
  \\[12pt]
\caption{Type system for formal terms}
\label{fig:formalterms}
\end{figure}
It can be formalized as an inductive family
parameterized by arities and indexed by sorts. 
\begin{code}
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}}}%
\>[11]\AgdaSymbol{(}\AgdaBound{ar'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Arity}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaInductiveConstructor{\#}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{ar'}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{ar'}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‼}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\>[3]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∣\$∣\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}%
\>[113I]\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaBound{Σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[113I][@{}l@{\AgdaIndent{0}}]%
\>[15]\AgdaDatatype{HVec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar'}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{ar'}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

A formal term specifies how to interpret an operation from the source
signature in the target signature. The arity \AgdaBound{ar'} specifies the sort
of each argument of the original operation. For example, since the
operation \AgdaInductiveConstructor{neg} is unary, we can use one identifier when defining its
translation. Notice that \AgdaFunction{bool-sig} and \AgdaFunction{bool-sig'} share the sorts; in
general, one also considers a mapping between sorts.

A \emph{derived signature morphism} consists of a mapping between sorts
and a mapping from operations to formal terms:
\begin{code}
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{\AgdaUnderscore{}↝\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Signature}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{FormalTerm}\AgdaSpace{}%
\AgdaBound{Σₜ}\<%
\\
%
\>[1]\AgdaKeyword{field}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaField{↝ₛ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σₜ}\<%
\\
%
\>[2]\AgdaField{↝ₒ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}%
\>[17]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{lmap}\AgdaSpace{}%
\AgdaField{↝ₛ}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaField{↝ₛ}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}
\noindent We show the action of the morphism on the operations \codigo{neg| and |and}
\begin{code}
\>[2]\AgdaFunction{ops↝}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Σops₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{s}\<%
\\
%
\>[2]\AgdaFunction{ops↝}\AgdaSpace{}%
\AgdaInductiveConstructor{or₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{or₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∣\$∣}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨⟨}}\AgdaSpace{}%
\AgdaFunction{p}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{q}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩⟩}}\<%
\\
%
\>[2]\AgdaFunction{ops↝}\AgdaSpace{}%
\AgdaInductiveConstructor{neg₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{equiv₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∣\$∣}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨⟨}}\AgdaSpace{}%
\AgdaFunction{p}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{f₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∣\$∣}}\AgdaSpace{}%
\AgdaInductiveConstructor{⟨⟩}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩⟩}}\<%
\end{code}
\noindent where \AgdaFunction{p}\AgdaSpace{}\AgdaSymbol{=}\AgdaInductiveConstructor{\#}\AgdaSpace{}\AgdaInductiveConstructor{zero} and \AgdaFunction{q}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaInductiveConstructor{\#}\AgdaSpace{}\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaInductiveConstructor{zero}\AgdaSymbol{)}.

\subsection{Transformation of Algebras}
\newcommand{\intSign}[2]{#1 ↝ #2}
\newcommand{\intTheo}[1]{\widetilde{\theory{#1}}}
\newcommand{\algTrans}[1]{\langle \mathcal{#1} \rangle}
\newcommand{\mapSort}[2]{#1\,#2}
\newcommand{\mapOp}[2]{#1\,#2}

A signature morphism
$m\colon\intSign{\Sigma_s}{\Sigma_t}$ induces a functor from
$\Sigma_t$-algebras to
$\Sigma_s$-algebras.  Given a $\Sigma_t$-algebra
$\mathcal{A}$, we denote with
$\algTrans{A}$ the corresponding
$\Sigma_s$-algebra, which is known as the \emph{reduct algebra with
  respect to the morphism} $m$. Let us sketch the construction of
the functor on algebras: the interpretation of a $\Sigma_s$-sort $s$ is given by
  $\algTrans{A}_s = \mathcal{A}_{(\mapSort{m}{s})}$ and
for interpreting an operation $f$ in the reduct algebra
$\algTrans A$ we use the interpretation of the formal term $m f$, which
is recursively defined by
\begin{code}
\>[4]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧⊢}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥*}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaInductiveConstructor{\#}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧⊢}}%
\>[16]\AgdaBound{as}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[22]\AgdaBound{as}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‼v}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∣\$∣}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧⊢}}%
\>[19]\AgdaBound{as}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₒ}}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟨\$⟩}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧⊢*}}\AgdaSpace{}%
\AgdaBound{as}\<%
\end{code}
\noindent Identifiers denote projections and the application of the
operation \AgdaBound{f} to formal terms \AgdaBound{ts} is interpreted as the interpretation of \AgdaBound{f}
applied to the denotation of each term in \AgdaBound{ts}, the function \AgdaOperator{\AgdaFunction{⟦}}%
\AgdaUnderscore{}%
\AgdaOperator{\AgdaFunction{⟧⊢*}} extends
\AgdaOperator{\AgdaFunction{⟦}}%
\AgdaUnderscore{}%
\AgdaOperator{\AgdaFunction{⟧⊢}} to vectors.

We can formalize the reduct algebra in a direct way, however the
interpretation of operations is a little more complicated, since we
need to convince Agda that any vector
\AgdaBound{vs}\AgdaSpace{}\AgdaSymbol{:}%
\AgdaSpace{}\AgdaDatatype{HVec}\AgdaSpace{}\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaUnderscore{}\AgdaOperator{\AgdaFunction{⟧ₛ}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘↝ₛ}}\AgdaSymbol{)}\AgdaBound{is} has also
the type \AgdaDatatype{HVec}\AgdaSpace{}\AgdaBound{A}\AgdaSymbol{(}\AgdaFunction{map}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{↝ₛ}}\AgdaSpace{}\AgdaBound{is}\AgdaSymbol{)}, which is accomplished by
\AgdaFunction{reindex}-ing the vector (we omit the proof of \AgdaFunction{cong}):
\begin{code}
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{ReductAlgebra}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{↝}}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{where}\<%
%
\\
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟨\AgdaUnderscore{}⟩ₛ}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}%
\>[13]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}%
\AgdaBound{Σₛ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Setoid}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
%
\>[2]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩ₛ}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaField{↝ₛ}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\<%
%\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟨\AgdaUnderscore{}⟩ₒ}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[11]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ops}\AgdaSpace{}%
\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨\AgdaUnderscore{}⟩ₛ}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{✳}}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟶}}%
\>[93]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩ₛ}}\<%
\\
%
\>[2]\AgdaBound{A}%
\>[949I]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩ₒ}}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[953I]\AgdaKeyword{record}%
\>[21]\AgdaSymbol{\{}%
\>[24]\AgdaOperator{\AgdaField{\AgdaUnderscore{}⟨\$⟩\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{↝ₒ}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{reindex}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{↝ₛ}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\>[20]\AgdaSymbol{;}%
\>[23]\AgdaField{cong}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[31]\ensuremath{\ldots}\AgdaSpace{}\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{〈\AgdaUnderscore{}〉}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Algebra}\AgdaSpace{}%
\AgdaBound{Σₛ}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{〈}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{〉}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}⟦\AgdaUnderscore{}⟧ₛ}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨\AgdaUnderscore{}⟩ₛ}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}⟦\AgdaUnderscore{}⟧ₒ}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨\AgdaUnderscore{}⟩ₒ}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
\noindent The action of the functor on homomorphisms is also straightforward.

A more interesting example of signature morphisms and reduct algebras
is the definition of a compiler as presented in
\cite{thatcher1981more}. One defines a signature for the source
language and another one for the target language; these languages are
the term algebras over their respective signatures. A compiler is
specified by a signature morphism from the source signature to the
target signature: indeed the compiler is obtained as the unique
homomorphism from the source algebra to the reduct algebra of the
target algebra. Moreover, one can obtain a correct compiler by
providing semantics of each language as algebras and a morphism
between the source semantics and the reduct of the target
semantics.\footnote{We explored this idea by defining a correct
  compiler for an arithmetic language targeting a stack-based
  language; it can be found at the repository in
  \nolinkurl{Examples/CompilerArith.agda}.}


\newcommand{\theory}[1]{\ensuremath{\mathit{E}_{#1}}}

\subsection{Translation of theories} From a signature morphism
$m : \intSign{\Sigma_s}{\Sigma_t}$ one gets the translation of ground
\AgdaBound{Σₛ} terms as the initial homomorphism from \tsigmaeq{Σₛ} to
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}\AgdaFunction{∣T∣}\AgdaSpace{}\AgdaBound{Σₜ}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⟩}}. With an appropriate extension to variables, this translation
applied to a theory $\theory{s}$ over $\Sigma_s$ yields the theory
$\intTheo{s}$ over $\Sigma_t$. Moreover if
$\mathcal{A}_t\models\intTheo{s}$, one would think that the reduct
$\langle \mathcal{A}_t \rangle$ is a model of the original theory, \ie
$\langle \mathcal{A}_t \rangle \models \theory{s}$. Even better, if
$\theory{t}$ is a stronger theory than the translated theory
$\intTheo{s}$ and if $\mathcal{A}_t$ is a model for $\theory{t}$, we
would like that the reduct algebra models $\theory{s}$. In Agda such a
result would be realized as a function
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}↝T}} with
the following type (where \AgdaOperator{\AgdaFunction{↝*}}\AgdaSpace{}\AgdaBound{Eₛ} is the translation of \AgdaBound{Eₛ} and \AgdaFunction{lmap} is \AgdaFunction{map} of lists):

\begin{code}
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}↝T}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ar}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Thₛ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaBound{Σₛ}\AgdaSpace{}%
\AgdaBound{Xₛ}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Theory}\AgdaSpace{}%
\AgdaBound{Σₜ}\AgdaSpace{}%
\AgdaFunction{Xₜ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{lmap}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{↝ₛ}\AgdaSpace{}%
\AgdaBound{Σ↝}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSymbol{)}\<%
\end{code}
With the morphism $m : \intSign{\Sigma_s}{\Sigma_t}$ and a function
\AgdaOperator{\AgdaFunction{↝ᵥ}}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{sorts}\AgdaSpace{}\AgdaBound{Σₛ}\AgdaSymbol{\}}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}\AgdaBound{Xₛ}\AgdaSpace{}\AgdaBound{s}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}\AgdaBound{Xₜ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}\AgdaOperator{\AgdaFunction{↝ₛ}}\AgdaSpace{}\AgdaBound{s}%
\AgdaSymbol{)}\AgdaSpace{} to rename variables, one can define the
translation of open terms from \tsigmaeq{Σₛ} to \tsigmaeq{Σₜ} using
initiality.  In general, however, we cannot prove the
\emph{satisfaction property}: if a $\Sigma_t$-algebra models the
translation of an equation, then its reduct models the original
equation. The technical issue is the impossibility of defining a
$\Sigma_t$-environment from a $\Sigma_s$-environment. There is a
well-known solution which consists on restricting the set of variable
of the target signature by letting
$X_t = \bigcup_{s \in \Sigma_s , t = m \hookrightarrow s} X_s$.  Under
this restriction, we can prove the satisfaction property and
furthermore define the function
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}↝T}}. Such a restriction
over the set of variables seems to us as an impediment, which can be
alleviated if the original variables of $\theory{t}$ are included in
the calculated set of variables.