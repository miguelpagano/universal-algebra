-- Algebra generated by a set.
open import UnivAlgebra
open import Level renaming (zero to lzero ; suc to lsuc)
open import Equational
module SubAlgebra {lsig lops lvars ℓ₁ ℓ₂}{Σ : Sign lsig lops} {X : 𝓥 Σ lvars} (A : Alg {ℓ₁} {ℓ₂} Σ) where

open import Relation.Binary
open import Relation.Unary renaming (_⊆_ to _⊆r_) hiding (_⇒_)
open import Data.Product renaming (map to ×f) hiding(Σ)
open import Data.List
open import Function as F hiding (Injective; Bijective; Surjective;module Injection;Injection)
open import Function.Equality as FE renaming (_∘_ to _∘ₛ_) hiding (setoid;_⇨_)
open import Function.Bijection hiding (_∘_)
open import Function.Surjection hiding (_∘_)
open import Function.Injection hiding (_∘_)

open import Morphisms
open import Setoids
open import HeterogeneousVec renaming (map to mapV)

open SetoidPredicate
Predicate : (ℓ₃ : Level) → Set (lsig ⊔ lsuc (ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃))
Predicate ℓ₃ = (s : sorts Σ) → SetoidPredicate {ℓ₃ = ℓ₃} (A ⟦ s ⟧ₛ)

_⊆ₚ_ : ∀ {ℓ₃ ℓ₄} → Predicate ℓ₃ → Predicate ℓ₄ → Set (lsig ⊔ ℓ₁ ⊔ ℓ₃ ⊔ ℓ₄)
P ⊆ₚ Q = (s : sorts Σ) → predicate (P s) ⊆r predicate (Q s)

_⊆ₚ*_ : ∀ {ℓ₃ ℓ₄} → Predicate ℓ₃ → Predicate ℓ₄ → Set (lsig ⊔ ℓ₁ ⊔ ℓ₃ ⊔ ℓ₄)
P ⊆ₚ* Q = ∀ ar → ((predicate ∘ P) ⇨v ) {is = ar} ⊆r ((predicate ∘ Q) ⇨v ) {is = ar}

IxPredicate : (ℓ₃ ℓ₄ : Level) → Set _
IxPredicate ℓ₃ ℓ₄ = Pred (Predicate  ℓ₃) ℓ₄

-- The Intersection of an OpClosed family of predicates is OpClosed.
⋂p : ∀ {ℓ₃ ℓ₄} → IxPredicate ℓ₃ ℓ₄ → Predicate _
⋂p P s = record {  predicate = λ x → ∀ Q → P Q → predicate (Q s) x
                 ; predWellDef = λ eq p Q → predWellDef (Q s) eq ∘ p Q
                 }

⋂-OpClosed : ∀ {ℓ₃ ℓ₄} (P : IxPredicate ℓ₃ ℓ₄) →
             (∀ Q → P Q → OpClosed A (predicate ∘ Q)) →
             OpClosed A (predicate ∘ ⋂p {ℓ₃ = ℓ₃} {ℓ₄} P)
⋂-OpClosed P isClosed f vs Q pQ = isClosed Q pQ f (map⇨v (λ v → v Q pQ) vs)

open SubAlg
⋂-SubAlg : ∀ {ℓ₃ ℓ₄} (P : IxPredicate ℓ₃ ℓ₄) →
             (∀ Q → P Q → OpClosed A (predicate ∘ Q)) →
             SubAlg {ℓ₃ = lsig ⊔ lsuc ℓ₁ ⊔ lsuc ℓ₂ ⊔ lsuc ℓ₃ ⊔ ℓ₄} A
⋂-SubAlg {ℓ₃} {ℓ₄} P isClosed = record
             { pr = ⋂p {ℓ₃} {ℓ₄} P
             ; opClosed = ⋂-OpClosed {ℓ₃} P isClosed
             }
⋂-SubAlg' : ∀ {ℓ₃ ℓ₄} → (P : Pred (SubAlg {ℓ₃ = ℓ₃} A) ℓ₄) →
              SubAlg {ℓ₃ = lsuc lsig ⊔ lsuc lops ⊔ lsuc ℓ₁ ⊔ lsuc ℓ₂ ⊔ lsuc ℓ₃ ⊔ ℓ₄} A
⋂-SubAlg' {ℓ₃} {ℓ₄} P = record
             { pr = pred
             ; opClosed = λ f vs Q pq → opClosed Q f (map⇨v (λ v → v Q pq) vs)
             }
     where pred : Predicate _
           pred s = record { predicate = λ x → ∀ Q → P Q → predicate (pr Q s) x
                           ; predWellDef = λ eq pres Q → predWellDef (pr Q s) eq ∘ pres Q
                           }


-- Algebra generated by a SetoidPredicate (not necessarily OpClosed).
<_>_ : ∀ {ℓ₃ ℓ₄} → (X : Predicate ℓ₃) → (P : Pred (SubAlg {ℓ₃ = ℓ₃} A) ℓ₄) →
         SubAlg {ℓ₃ = _} A
<_>_ {ℓ₃ = ℓ₃} {ℓ₄} X P = ⋂-SubAlg' λ Q → P Q × (X ⊆ₚ pr Q)

-- Inductive definition.

data E {ℓ₃} (X : Predicate ℓ₃) (s : sorts Σ) : Setoid.Carrier (A ⟦ s ⟧ₛ) → Set (lsig ⊔ lops ⊔ ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃) where
  inX : ∀ {a} → predicate (X s) a → E X s a
  img : ∀ {a} {ar} {f : ops Σ (ar , s)} (ts : HVec (λ x → ∃ (λ a' → E X x a')) ar) →
          Setoid._≈_ (A ⟦ s ⟧ₛ) ((A ⟦ f ⟧ₒ ⟨$⟩ mapV (λ _ → proj₁) ts)) a →
              E X s a


E-WellDefined : ∀ {ℓ₃}→ (X : Predicate ℓ₃) → (s : sorts Σ) → WellDef (A ⟦ s ⟧ₛ) (E X s)
E-WellDefined X s {y = y} a≈b (inX x) = inX (predWellDef (X s) a≈b x)
E-WellDefined X s {y = y} a≈b (img ts a≈f-ts) = img ts (trans a≈f-ts a≈b)
  where open Setoid (A ⟦ s ⟧ₛ)

E-Pred : ∀ {ℓ₃} → (X : Predicate ℓ₃) → Predicate _
E-Pred X s = record { predicate = E X s
                    ; predWellDef = E-WellDefined X s
                    }

X⊆E : ∀ {ℓ₃} (X : Predicate ℓ₃) → X ⊆ₚ E-Pred X
X⊆E X s a∈X = inX a∈X

E-opClosed : ∀ {ℓ₃} → (X : Predicate ℓ₃) → OpClosed A (predicate ∘ E-Pred X)
E-opClosed X {ar} {s} f {ts} tsp = img {f = f} (⇨vtoΣ tsp) prop
  where open Setoid (A ⟦ s ⟧ₛ)
        prop : (A ⟦ f ⟧ₒ) ⟨$⟩ mapV (λ _ → proj₁) (⇨vtoΣ tsp) ≈ (A ⟦ f ⟧ₒ) ⟨$⟩ ts
        prop rewrite proj₁-inv-⇨vtoΣ tsp = refl


E-SubAlg : ∀ {ℓ₃} → (X : Predicate ℓ₃) → SubAlg {ℓ₃ = lsig ⊔ lops ⊔ ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃} A
E-SubAlg X = record { pr = E-Pred X ; opClosed = E-opClosed X }

-- Algebra generated by a SetoidPredicate (not necessarily OpClosed).
⟨_⟩ : ∀ {ℓ₃} → (X : Predicate ℓ₃) → Alg Σ
⟨_⟩ {ℓ₃ = ℓ₃} X  = SubAlgebra (E-SubAlg X)

-- Equivalence between ⋂-SubAlg' and E-SubAlg, stated in terms of predicates.
E⊆⋂-Sub : ∀ {ℓ₃} → (X : Predicate ℓ₃) →
        pr (⋂-SubAlg' {ℓ₃ = lsig ⊔ lops ⊔ ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃ } (λ Q → X ⊆ₚ pr Q)) ⊆ₚ E-Pred X
E⊆⋂-Sub X s a = a (E-SubAlg X) (X⊆E X)

⋂-Sub⊆E : ∀ {ℓ₃} → (X : Predicate ℓ₃) →
        E-Pred X ⊆ₚ
        pr (⋂-SubAlg' {ℓ₃ = ℓ₁ ⊔ ℓ₂ ⊔ ℓ₃ } (λ Q → X ⊆ₚ pr Q))
⋂-Sub⊆E* : ∀ {ℓ₃} → (X : Predicate ℓ₃) → ∀ Q → X ⊆ₚ pr Q →
         ∀ {ar}
        (ts : HVec (λ x → ∃ (λ a' → E X x a')) ar) →
        (predicate ∘ pr Q) ⇨v mapV (λ _ → proj₁) ts

⋂-Sub⊆E X s (inX x) Q X⊆Q = X⊆Q s x
⋂-Sub⊆E X s (img {a} {ar} {f} tsE x) Q X⊆Q = predWellDef (pr Q s) x f-tsQ
  where f-tsQ : predicate (pr Q s) ((A ⟦ f ⟧ₒ) ⟨$⟩ mapV (λ _ → proj₁) tsE)
        f-tsQ = opClosed Q f (⋂-Sub⊆E* X Q X⊆Q tsE )

⋂-Sub⊆E* X Q X⊆Q ⟨⟩ = ⇨v⟨⟩
⋂-Sub⊆E* X Q X⊆Q {s ∷ _} (v ▹ ts) = ⇨v▹ (⋂-Sub⊆E X s (proj₂ v) Q X⊆Q)
                                            (⋂-Sub⊆E* X Q X⊆Q ts)


≅-SubAlg : ∀ {ℓ₃ ℓ₄} → (B : SubAlg {ℓ₃ = ℓ₃} A) → (C : SubAlg {ℓ₃ = ℓ₄} A) → Set _
≅-SubAlg B C = pr B ⊆ₚ pr C × pr C ⊆ₚ pr B

≅-SubAlg-iso : ∀ {ℓ₃ ℓ₄} → (B : SubAlg {ℓ₃ = ℓ₃} A) → (C : SubAlg {ℓ₃ = ℓ₄} A) →
               ≅-SubAlg B C → Isomorphism (SubAlgebra B) (SubAlgebra C)
≅-SubAlg-iso {ℓ₃} {ℓ₄} B C (B≤C , C≤B) =
               record { hom = H
                      ; bij = λ s → record { injective = F.id
                                           ; surjective = isSurj s
                                           }
                      }
   where open Hom
         open Homo
         ′H′ : ∀ s → (SubAlgebra B) ⟦ s ⟧ₛ ⟶ (SubAlgebra C) ⟦ s ⟧ₛ
         ′H′ s = record { _⟨$⟩_ = ×f F.id (B≤C s)
                        ; cong = F.id
                        }
         Hcond : homCond (SubAlgebra B) (SubAlgebra C) ′H′
         Hcond {s = s} f as
           rewrite propMapV∘ as (λ i → ×f F.id (B≤C i)) (λ _ → proj₁) = Setoid.refl (A ⟦ s ⟧ₛ)
         H : Homo (SubAlgebra B) (SubAlgebra C)
         H = record { ′_′ = ′H′
                    ; cond = Hcond
                    }

         H⁻¹ : ∀ s → (SubAlgebra C) ⟦ s ⟧ₛ ⟶ (SubAlgebra B) ⟦ s ⟧ₛ
         H⁻¹ s = record { _⟨$⟩_ = ×f F.id (C≤B s)
                        ; cong = F.id
                        }
         isSurj : ∀ s → Surjective (′ H ′ s)
         isSurj s = record { from = H⁻¹ s
                           ; right-inverse-of = λ _ → Setoid.refl (A ⟦ s ⟧ₛ)
                           }
open Universe Σ
_⊆ₛ_ : ∀ {ℓ₁} {ℓ₂} {ℓ₃} {ℓ₄} → Universe ℓ₁ ℓ₂ → Universe ℓ₃ ℓ₄ → Set _
_⊆ₛ_ {ℓ₁} {ℓ₂} {ℓ₃} {ℓ₄} X A = ∀ {s} → Injection {ℓ₁} {ℓ₂} {ℓ₃} {ℓ₄} (X s) (A s)

Img : ∀ {ℓ₃} {ℓ₄} {X : Universe ℓ₃ ℓ₄} → (X ⊆ₛ (A ⟦_⟧ₛ)) → Predicate (ℓ₂ ⊔ ℓ₃)
Img {X} X⊆ₛA s = record { predicate = λ a → ∃ (λ x → a ≈ (to ⟨$⟩ x))
                        ; predWellDef = λ { eq (x , eq') → x , trans (sym eq) eq' }
                        }
    where open Injection (X⊆ₛA {s})
          open Setoid (A ⟦ s ⟧ₛ)

⟨_⟩' : ∀ {ℓ₃} {ℓ₄} {X : Universe ℓ₃ ℓ₄} → (X ⊆ₛ (A ⟦_⟧ₛ)) → Alg Σ
⟨ X⊆A ⟩' = ⟨ Img X⊆A ⟩

open Setoid

module Free {ℓ₃} {ℓ₄} {X : Universe ℓ₃ ℓ₄} where
  data Free  : (s : sorts Σ) → Set (ℓ₃ ⊔ ℓ₄ ⊔ lsig ⊔ lops)  where
    var : ∀ {s : sorts Σ} (x : Carrier (X s)) →  Free s
    app : ∀ {ar s} →  (f : ops Σ (ar ↦ s)) → (HVec Free ar) → Free s

  data ≈F : (s : sorts Σ) → Rel (Free s) (lsig ⊔ lops ⊔ ℓ₃ ⊔ ℓ₄) where
    ≈var : ∀ {s} {x y} → _≈_ (X s) x y → ≈F s (var x) (var y)
    ≈fun : ∀ {ar} {s} → (f : ops Σ (ar ↦ s)) →
             ∀ {ts ts' : HVec Free ar} → _∼v_ {R = ≈F} ts ts' →
             ≈F s (app f ts) (app f ts')

  isRefl : ∀ s → Reflexive (≈F s)
  isRefl* : ∀ ar → Reflexive (_∼v_ {R = ≈F} {is = ar})
  isRefl* [] {x = ⟨⟩} = ∼⟨⟩
  isRefl* (s ∷ ar) {x = v ▹ x} = ∼▹ (isRefl s {v}) (isRefl* ar {x})
  isRefl s {var x} = ≈var (refl (X s))
  isRefl s {app {ar} f x} = ≈fun f (isRefl* ar {x})
  isSym : ∀ s → Symmetric (≈F s)
  isSym* : ∀ ar → Symmetric (_∼v_ {R = ≈F} {is = ar})
  isSym s (≈var x) = ≈var (sym (X s) x)
  isSym s (≈fun {ar} f x) = ≈fun f (isSym* ar x)
  isSym* [] ∼⟨⟩ = ∼⟨⟩
  isSym* (s ∷ ar) (∼▹ eq eqs) = ∼▹ (isSym s eq) (isSym* ar eqs)
  isTrans : ∀ s → Transitive (≈F s)
  isTrans* : ∀ ar → Transitive (_∼v_ {R = ≈F} {is = ar})
  isTrans* [] ∼⟨⟩ ∼⟨⟩ = ∼⟨⟩
  isTrans* (s ∷ ar) (∼▹ eq eqs) (∼▹ eq' eqs') = ∼▹ (isTrans s eq eq') (isTrans* ar eqs eqs')
  isTrans s (≈var eq) (≈var eq') = ≈var (trans (X s) eq eq')
  isTrans s (≈fun {ar} f eqs) (≈fun {.ar} .f eqs') = ≈fun f (isTrans* ar eqs eqs')

  ≈FisEquiv : ∀ s → IsEquivalence (≈F s)
  ≈FisEquiv s = record { refl = isRefl s
                       ; sym = isSym s
                       ; trans = isTrans s
                       }

  freeSetoid : (s : sorts Σ) → Setoid (lsig ⊔ lops ⊔ ℓ₃ ⊔ ℓ₄) (lsig ⊔ lops ⊔ ℓ₃ ⊔ ℓ₄)
  freeSetoid s = record { Carrier = Free s
                      ; _≈_ = ≈F s
                      ; isEquivalence = ≈FisEquiv s
                      }

  freeAlgebra : Alg {lsig ⊔ lops ⊔ ℓ₃ ⊔ ℓ₄} {lsig ⊔ lops ⊔ ℓ₃ ⊔ ℓ₄} Σ
  freeAlgebra = record { _⟦_⟧ₛ = freeSetoid
                       ; _⟦_⟧ₒ = ∣_∣o
                       }
   where ∣_∣o  : ∀ {ar s} → ops Σ (ar ↦ s) → freeSetoid ✳ ar ⟶ freeSetoid s
         ∣ f ∣o = record { _⟨$⟩_ = app f
                       ; cong = ≈fun f
                       }




module FreeExt {ℓ₃} {ℓ₄} {X : Universe ℓ₃ ℓ₄} {ℓ₁ ℓ₂} (B : Alg {ℓ₁} {ℓ₂} Σ) (θ : X ⊆ₛ (B ⟦_⟧ₛ)) where
  open Free {X = X}
  open Injection
  open Hom
  open Homo

  open Injection
  mutual
    ∣h∣→A : ∀ {s} → Free s → ∥ B ⟦ s ⟧ₛ ∥
    ∣h∣→A (var {s} x) = to (θ {s}) ⟨$⟩ x
    ∣h∣→A (app f x) = B ⟦ f ⟧ₒ ⟨$⟩ map|h|→A x

    map|h|→A : ∀ {ar} → HVec Free ar → B ⟦ ar ⟧ₛ*
    map|h|→A ⟨⟩ = ⟨⟩
    map|h|→A (t ▹ ts) = ∣h∣→A t ▹ map|h|→A ts

  congfun : ∀ {s} {t₁ t₂ : Free s} → ≈F s t₁ t₂ → _≈_ (B ⟦ s ⟧ₛ) (∣h∣→A t₁) (∣h∣→A t₂)
  congfun* : ∀ {ar} {t₁ t₂ : HVec Free ar} →  _∼v_ {R = ≈F} t₁ t₂ →
                                              _∼v_ {R = λ s → _≈_ (B ⟦ s ⟧ₛ)} (map|h|→A t₁) (map|h|→A t₂)
  congfun* {.[]} ∼⟨⟩ = ∼⟨⟩
  congfun* {.(_ ∷ _)} (∼▹ eq eqs) = ∼▹ (congfun eq) (congfun* eqs)
  congfun {s} (≈var x) = cong (to (θ {s})) x
  congfun {s} (≈fun f x) = cong (B ⟦ f ⟧ₒ) (congfun* x)
  fun|T|ₕ : freeAlgebra ⟿ B
  fun|T|ₕ s = record { _⟨$⟩_ = ∣h∣→A {s = s}
                     ; cong  = congfun {s}
                     }

  map|h|-≈ : ∀ {ar} ts → _∼v_ {R = λ s → _≈_ (B ⟦ s ⟧ₛ)} {is = ar} (map|h|→A ts) (mapV (λ x → ∣h∣→A) ts)
  map|h|-≈ ⟨⟩ = ∼⟨⟩
  map|h|-≈ {s ∷ _} (v ▹ ts) = ∼▹ (refl (B ⟦ s ⟧ₛ)) (map|h|-≈ ts)
  |T|ₕcond : (homCond freeAlgebra B) fun|T|ₕ
  |T|ₕcond {_} {s} f ts = cong (B ⟦ f ⟧ₒ) (map|h|-≈ ts)

  open Hom
  ∣H∣ : Homo freeAlgebra B
  ∣H∣ = record { ′_′  = fun|T|ₕ
                 ; cond = |T|ₕcond
                 }

  extends-θ : (H : Homo freeAlgebra B) → Set _
  extends-θ H = ∀ s (x : Carrier (X s)) →
            Setoid._≈_ (B ⟦ s ⟧ₛ) (′ H ′ s ⟨$⟩ var x) (to θ ⟨$⟩ x)

  import Relation.Binary.EqReasoning as EqR

  _≈h_ : _
  _≈h_ = _≈ₕ_ freeAlgebra B
  UMP : ∀ (H : Homo freeAlgebra B) → extends-θ H → H ≈h ∣H∣
  UMP H prop s (var x) = prop s x
  UMP H prop s (app {ar} f ts) =
          begin
            ′ H ′ s ⟨$⟩ app f ts
              ≈⟨ cond H f ts ⟩
            B ⟦ f ⟧ₒ ⟨$⟩ mapV (_⟨$⟩_ ∘ ′ H ′) ts
              ≈⟨ Π.cong (B ⟦ f ⟧ₒ) (map≈ ar ts) ⟩
            ′ ∣H∣ ′ s ⟨$⟩ app f ts
          ∎
    where open EqR (B ⟦ s ⟧ₛ)
          map≈ : (ar : Arity Σ) → (ts : HVec Free ar) →
                 (mapV (_⟨$⟩_ ∘ ′ H ′) ts) ∼v (map|h|→A ts)
          map≈ [] ⟨⟩ = ∼⟨⟩
          map≈ (s ∷ ar) (t ▹ ts) = ∼▹ (UMP H prop s t) (map≈ ar ts) 


module Gen {ℓ₃ ℓ₄ : Level} {X : Universe ℓ₃ ℓ₄} (ι : X ⊆ₛ (A ⟦_⟧ₛ))  where
  open Free {X = X}
  open FreeExt A ι
  open Hom
  open Setoid
  open Injection


  ⊆E : ∀ s t → predicate (E-Pred (Img ι) s) (∣h∣→A t)
  ⊆E* : ∀ ar (ts : HVec Free ar) → HVec ((λ x → ∃ (λ a' → E (Img ι) x a'))) ar
  proj₁⊆E* : ∀ ar (ts : HVec Free ar) →
       _≈_ ((λ s → A ⟦ s ⟧ₛ) ✳ ar) (mapV (λ _ → proj₁) (⊆E* ar ts)) (map|h|→A ts)
  ⊆E* [] ⟨⟩ = ⟨⟩
  ⊆E* (x ∷ ar) (v ▹ ts) = (∣h∣→A v , ⊆E x v) ▹ ⊆E* ar ts
  proj₁⊆E* [] ⟨⟩ = ∼⟨⟩
  proj₁⊆E* (s ∷ ar) (v ▹ ts) = ∼▹ (refl (A ⟦ s ⟧ₛ)) (proj₁⊆E* ar ts )
  ⊆E s (var x) = inX (x , refl (A ⟦ s ⟧ₛ))
  ⊆E s (app {ar = ar} f ts) = img {f = f} (⊆E* ar ts) (cong (A ⟦ f ⟧ₒ) (proj₁⊆E* ar ts))

  ⊇E : ∀ s a → predicate (E-Pred (Img ι) s) a → ∃ (λ t → _≈_ (A ⟦ s ⟧ₛ) a (∣h∣→A t))
  ⊇E*1 : ∀ ar (ts : HVec (λ x₁ → ∃ (E (Img ι) x₁)) ar) →
    HVec Free ar
  ⊇E* : ∀ ar (ts : HVec (λ x₁ → ∃ (E (Img ι) x₁)) ar) →
    HVec (λ x → ∃ (λ a → ∃ (λ t → _≈_ (A ⟦ x ⟧ₛ) a (∣h∣→A t)))) ar
  proj₁⊇E* : ∀ ar (ts : HVec (λ x₁ → ∃ (E (Img ι) x₁)) ar) →
       _≈_ ((λ s → A ⟦ s ⟧ₛ) ✳ ar) (mapV (λ _ → proj₁) ts)
                 (map|h|→A (⊇E*1 ar ts))
  ⊇E*1 [] ⟨⟩ = ⟨⟩
  ⊇E*1 (x ∷ ar) ((a , p) ▹ ts) = (proj₁ (⊇E x a p)) ▹ ⊇E*1 ar ts
  ⊇E* [] ⟨⟩ = ⟨⟩
  ⊇E* (x ∷ ar) ((a , p) ▹ ts) = (a , ⊇E x a p) ▹ ⊇E* ar ts
  proj₁⊇E* [] ⟨⟩ = ∼⟨⟩
  proj₁⊇E* (x ∷ ar) ((a , p) ▹ ts) = ∼▹ (proj₂ (⊇E x a p)) (proj₁⊇E* ar ts)
  ⊇E s a (inX (x , eq)) = var x , eq
  ⊇E s a (img {ar = ar} {f} ts x) =
    (app f (⊇E*1 ar ts)) , trans (A ⟦ s ⟧ₛ) (sym (A ⟦ s ⟧ₛ) x) (Π.cong (A ⟦ f ⟧ₒ) (proj₁⊇E* ar ts))


  E⊆H : E-Pred (Img ι) ⊆ₚ  pr (SubImg freeAlgebra A ∣H∣)
  E⊆H s {a} p = proj₁ (⊇E s a p) , sym (A ⟦ s ⟧ₛ) (proj₂ (⊇E s a p))
  H⊆E : pr (SubImg freeAlgebra A ∣H∣) ⊆ₚ E-Pred (Img ι)
  H⊆E s {a} (t , eq) = E-WellDefined (Img ι) s eq (⊆E s t)

  ⟨ι⟩≅Imgι : ⟨ ι ⟩' ≅ homImg freeAlgebra ∣H∣
  ⟨ι⟩≅Imgι = record { iso = ≅-SubAlg-iso (E-SubAlg (Img ι)) (SubImg freeAlgebra A ∣H∣) (E⊆H , H⊆E) }

-- A is generated by X if ∀ a ∈ A, E a
IsGeneratedBy : ∀ {ℓ₃} → (X : Predicate ℓ₃) → Set _
IsGeneratedBy X = ∀ s a → E X s a
