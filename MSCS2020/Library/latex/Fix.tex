module Fix where

open import SomeDefinitions
open import Data.Nat as Nat 
  hiding (_⊔_)
open import Data.Bool
   hiding (_∨_)
open import Function
open import Data.Fin
  renaming (_<_ to _<F_)
  renaming (_≤_ to _≤F_)
open import Data.Vec
open import Data.Product
open import Data.Empty 
open import Data.Nat.Properties
open import Relation.Nullary


fixS :  (X : Set) → 
       (k : ℕ) →               -- maximun number of iterations
       (_⊏_ : X → X → Set) → 
       (_⊑_ : X → X → Set) →
       (sum : {x y : X} → x ⊑ y → (x ≡ y) ∨ (x ⊏ y)) →   
       (str : {x y : X} → x ⊏ y → x ⊑ y) →
       (par : PartialOrder _⊑_ ) →

       (bound : X → ℕ) →                     -- bound function 
       -- the bound function is decreasing 
       (∀ {x y : X} → x ⊏ y → bound y < bound x) →  
       -- the bound function has a unique minimal value
       (∀ (x y : X) → bound x ≡ 0 → bound y ≡ 0 → x ≡ y) → 

       (g : X → X) → 
       (∀ {x y} → x ⊑ y → g x ⊑ g y) → -- g is monotone

       (x : X) →                 -- inicials values   
       x ⊑ g x →                    -- x ⊑ g x 
       k ≥ bound x →              -- invariant
       Σ X (λ x → x ≡ g x ) 

fixS X 0 rel⊏ rel⊑ sum str par bound boundDec minimal g gmono x x⊑gx p 
   with minimal x (g x) (n≡0 p)
        (n≡0 (trans (propDec' bound rel⊏ rel⊑ sum boundDec x⊑gx) p))
        
fixS X 0 rel⊏ rel⊑ sum str par bound boundDec minimal g gmono x x⊑gx p |  x≡gx = x , x≡gx 


fixS X (suc n') rel⊏ rel⊑ sum str par bound boundDec minimal g gmono
    x x⊑gx p with sum x⊑gx
... | inl x≡gx = x , x≡gx 
... | inr x⊏gx = let r = p≤p (trans (boundDec x⊏gx) p)
                  in fixS X n' rel⊏ rel⊑ sum str par bound boundDec minimal g
                       gmono (g x) (gmono x⊑gx) r 


-------------------------------------------------------------------------------
-- This lemma lema is neccesary to prove that if we have two chains of the form: 
-- ⊥ Γ0''₁ Γ1''₁ Γ1''₁ 
-- ⊥ Γ0''₂ Γ1''₂ Γ2''₂ Γ3''₂ .. Γn''₂ 
-- then if Γ₁ ⊑ Γ₂,  Γ1''₁ ⊑ Γn''₂ is true

-- So, we have that Γi'' ⊑ Γn''
---------------------------------------------------------------------------------

lema'' :  (X : Set) → 
       (k : ℕ) →               -- maximun number of iterations
       (_⊏_ : X → X → Set) →
       (_⊑_ : X → X → Set) → 
       (sum : {x y : X} → x ⊑ y → (x ≡ y) ∨ (x ⊏ y)) →   
       (str : {x y : X} → x ⊏ y → x ⊑ y) →
       (par : PartialOrder _⊑_ ) → 
       
       (bound : X → ℕ) →                     -- bound function 
       -- the bound function is decreasing 
       (boundDec : ∀ {x y : X} → x ⊏ y → bound y < bound x) →  
       -- the bound function has a unique minimal value
       (minimal : ∀ (x y : X) → bound x ≡ 0 → bound y ≡ 0 → x ≡ y) → 

       (g₁ : X → X) → 
       (gmono₁ : ∀ {x y} → x ⊑ y → g₁ x ⊑ g₁ y) → -- g is monotone

       (g₂ : X → X) → 
       (gmono₂ : ∀ {x y} → x ⊑ y → g₂ x ⊑ g₂ y) → -- g is monotone

       (x : X) →                 -- inicials values  
       (x' : X) →                 -- inicials values   

       (x'⊑g₂x' : x' ⊑ g₂ x') →                    -- x ⊑ g x 
       (inv' : k ≥ bound x') →              -- invariant
       x ⊑ x' → 
       (prop : ∀ {x₁ x₂} → x₁ ⊑ x₂ → g₁ x₁ ⊑ g₂ x₂) →  
       x  ⊑ proj₁ (fixS X k _⊏_ _⊑_ sum str par bound boundDec minimal g₂ gmono₂ x' x'⊑g₂x' inv')

lema'' X 0 rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂
       x x' x'⊑g₂x' inv' x⊑x' prop
            with minimal x' (g₂ x') (n≡0 inv')
                    (n≡0 (trans (propDec' bound rel⊏  rel⊑ sum boundDec x'⊑g₂x') inv'))
lema'' X 0 rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂
       x  x' x'⊑y' inv' x⊑x' prop | l = x⊑x'

lema'' X (suc k) rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂
       x x' x'⊑g₂x' inv' x⊑x' prop with sum x'⊑g₂x'
lema'' X (suc k) rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂
       x x' x'⊑g₂x' inv' x⊑x' prop | inl x'≡g₂x' = x⊑x'
       
... | inr x'⊏g₂x' = let r :  k ≥ bound (g₂ x')
                        r = p≤p (trans (boundDec x'⊏g₂x') inv') 

                        x⊑g₂x' : rel⊑ x (g₂ x') 
                        x⊑g₂x' = PartialOrder.trans₁ par x⊑x' x'⊑g₂x' 
               in lema'' X k rel⊏ rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂
                    gmono₂ x (g₂ x') (gmono₂ x'⊑g₂x') r x⊑g₂x' prop


---------------------
-------------------------------------------------------------------------------
-- This lemma lema is neccesary to prove that if we have two chains of the form: 
-- ⊥ Γ0''₁ Γ1''₁ Γ2''₁ Γ3''₁ .. Γn''₁ 
-- ⊥ Γ0''₂ Γ1''₂ Γ1''₂ 
-- then if Γ₁ ⊑ Γ₂, Γn''₁ ⊑ Γ1''₁ is true
-------------------------------------------------------------------------------
---------------

lema' :  (X : Set) → 
       (k : ℕ) →               -- maximun number of iterations
       (_⊏_ : X → X → Set) →
       (_⊑_ : X → X → Set) → 
       (sum : {x y : X} → x ⊑ y → (x ≡ y) ∨ (x ⊏ y)) →   
       (str : {x y : X} → x ⊏ y → x ⊑ y) →
       (par : PartialOrder _⊑_ ) → 
       
       (bound : X → ℕ) →                     -- bound function 
       -- the bound function is decreasing 
       (boundDec : ∀ {x y : X} → x ⊏ y → bound y < bound x) →  
       -- the bound function has a unique minimal value
       (minimal : ∀ (x y : X) → bound x ≡ 0 → bound y ≡ 0 → x ≡ y) → 

       (g₁ : X → X) → 
       (gmono₁ : ∀ {x y} → x ⊑ y → g₁ x ⊑ g₁ y) → -- g is monotone

       (g₂ : X → X) → 
       (gmono₂ : ∀ {x y} → x ⊑ y → g₂ x ⊑ g₂ y) → -- g is monotone

       (x : X) →                 -- inicials values   
       (x⊑g₁x : x ⊑ g₁ x) →      -- x ⊑ g x 
       (inv : k ≥ bound x) →      -- invariant

       (x' : X) →                 -- inicials values   
       x ⊑ x' →
       x' ≡ g₂ x' → 
       (prop : ∀ {x₁ x₂} → x₁ ⊑ x₂ → g₁ x₁ ⊑ g₂ x₂) →  
       proj₁ (fixS X k _⊏_ _⊑_ sum str par bound boundDec minimal g₁ gmono₁ x x⊑g₁x inv) ⊑ x' 

lema' X 0 rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x⊑x' x'≡g₂x' prop with minimal x (g₁ x) (n≡0 inv)
                    (n≡0 (trans (propDec' bound rel⊏  rel⊑ sum boundDec x⊑g₁x) inv))
lema' X 0 rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x⊑x' x'≡g₂x' prop | l = x⊑x'

lema' X (suc k) rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x⊑x' x'≡g₂x' prop  with sum x⊑g₁x
lema' X (suc k) rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x⊑x' x'≡g₂x' prop | inl x≡g₁x = x⊑x' 
... | inr x⊏g₁x = let  inv₁ : k ≥ bound (g₁ x) 
                       inv₁ = p≤p (trans (boundDec x⊏g₁x) inv)
                       
                       g₁x⊑x' :  rel⊑ (g₁ x) x'
                       g₁x⊑x' = PartialOrder.trans₁ par (prop x⊑x')
                                                       (subst (λ y → rel⊑ y x') x'≡g₂x' (PartialOrder.refl₁ par {x = x'})) 

                in lema' X k rel⊏ rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂
                  gmono₂ (g₁ x) (gmono₁ x⊑g₁x) inv₁ x' g₁x⊑x' x'≡g₂x' prop 


-------- Lemma similar to fiSMonotone, but with different function g

fixSmonotone2 :  (X : Set) → 
       (k : ℕ) →               -- maximun number of iterations
       (_⊏_ : X → X → Set) →
       (_⊑_ : X → X → Set) → 
       (sum : {x y : X} → x ⊑ y → (x ≡ y) ∨ (x ⊏ y)) →   
       (str : {x y : X} → x ⊏ y → x ⊑ y) → 
       (par : PartialOrder _⊑_ ) → 
       
       (bound : X → ℕ) →                     -- bound function 
       -- the bound function is decreasing 
       (boundDec : ∀ {x y : X} → x ⊏ y → bound y < bound x) →  
       -- the bound function has a unique minimal value
       (minimal : ∀ (x y : X) → bound x ≡ 0 → bound y ≡ 0 → x ≡ y) → 

       (g₁ : X → X) → 
       (gmono₁ : ∀ {x y} → x ⊑ y → g₁ x ⊑ g₁ y) → -- g is monotone

       (g₂ : X → X) → 
       (gmono₂ : ∀ {x y} → x ⊑ y → g₂ x ⊑ g₂ y) → -- g is monotone

       (x : X) →                 -- inicials values   
       (x⊑g₁x : x ⊑ g₁ x) →                    -- x ⊑ g x 
       (inv : k ≥ bound x) →              -- invariant
       (x' : X) →                 -- inicials values   
       (x'⊑g₂x' : x' ⊑ g₂ x') →                    -- x ⊑ g x 
       (inv' : k ≥ bound x') →              -- invariant
       x ⊑ x' → g₁ x ⊑ g₂ x' →
       (prop : ∀ {x₁ x₂} → x₁ ⊑ x₂ → g₁ x₁ ⊑ g₂ x₂) →  
       proj₁ (fixS X k _⊏_ _⊑_ sum str par bound boundDec minimal g₁ gmono₁ x x⊑g₁x inv) ⊑
       proj₁ (fixS X k _⊏_ _⊑_ sum str par bound boundDec minimal g₂ gmono₂ x' x'⊑g₂x' inv')

fixSmonotone2 X 0 rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x'⊑g₂x' inv' x⊑x' g₁x⊑g₂x' prop with minimal x (g₁ x) (n≡0 inv)
          (n≡0 (trans (propDec' bound rel⊏ rel⊑ sum boundDec x⊑g₁x) inv))
       
... | x≡g₁x with  minimal x' (g₂ x') (n≡0 inv') (n≡0 (trans (propDec' bound rel⊏ rel⊑ sum boundDec x'⊑g₂x') inv'))
...        | x'≡g₂x' = x⊑x'  

fixSmonotone2 X (suc k) rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x'⊑g₂x' inv' x⊑x' g₁x⊑g₂x' prop with sum x⊑g₁x
...  | inl x≡g₁x  with sum x'⊑g₂x'
...              | inl x'≡g₂' = x⊑x'  
...              | inr x'⊏g₂x' = let x⊑g₂x' : rel⊑ x (g₂ x')
                                     x⊑g₂x' = PartialOrder.trans₁ par x⊑x' x'⊑g₂x'

                                     r :  k ≥ bound (g₂ x') -- 
                                     r = p≤p (trans (boundDec x'⊏g₂x') inv')
                                     
                                 in  lema'' X k rel⊏ rel⊑ sum str par bound boundDec minimal g₁
                                   gmono₁ g₂ gmono₂ x (g₂ x') (gmono₂ x'⊑g₂x') r x⊑g₂x' prop
                                   
fixSmonotone2 X (suc k) rel⊏  rel⊑ sum str par bound boundDec minimal g₁ gmono₁ g₂ gmono₂ x 
         x⊑g₁x inv x' x'⊑g₂x' inv' x⊑x' g₁x⊑g₂x' prop | inr x⊏g₁x with sum x'⊑g₂x'
... | inl x'≡g₂x' =  let   inv₁ : k ≥ bound (g₁ x)
                           inv₁ = p≤p (trans (boundDec x⊏g₁x) inv)
                           
                           g₁x⊑x' :  rel⊑ (g₁ x) x'
                           g₁x⊑x' = PartialOrder.trans₁ par g₁x⊑g₂x' (subst (λ y → rel⊑ y x') x'≡g₂x'
                                     (PartialOrder.refl₁ par {x = x'}))
                      in lema' X k rel⊏ rel⊑ sum str par bound boundDec minimal g₁
                               gmono₁ g₂ gmono₂ (g₁ x) (gmono₁ x⊑g₁x) inv₁ x' g₁x⊑x' x'≡g₂x' prop 
... | inr x'⊏g₂x' =  let inv₁ : k ≥ bound (g₁ x)
                         inv₁ = p≤p (trans (boundDec x⊏g₁x) inv)

                         inv₂ : k ≥ bound (g₂ x')
                         inv₂ = p≤p (trans (boundDec x'⊏g₂x') inv') 

                     in fixSmonotone2 X k rel⊏ rel⊑ sum str par bound boundDec
                      minimal g₁ gmono₁ g₂ gmono₂ (g₁ x) (gmono₁ x⊑g₁x) inv₁ (g₂ x')
                      (gmono₂ x'⊑g₂x') inv₂ (prop x⊑x') (prop (prop x⊑x')) prop



-----------------
-------- fixS is monotone
----------------------
fixSmonotone :  (X : Set) →    -- partial order Set
       (k : ℕ) →               -- maximun number of iterations
       (_⊏_ : X → X → Set) →
       (_⊑_ : X → X → Set) →  
       (sum : {x y : X} → x ⊑ y → (x ≡ y) ∨ (x ⊏ y)) →   
       (str : {x y : X} → x ⊏ y → x ⊑ y) →

       (par : PartialOrder _⊑_ ) →    
       
       (bound : X → ℕ) →      -- bound function 
       -- the bound function is decreasing 
       (boundDec : ∀ {x y : X} → x ⊏ y → bound y < bound x) →  
       -- the bound function has a unique minimal value
       (minimal : ∀ (x y : X) → bound x ≡ 0 → bound y ≡ 0 → x ≡ y) → 

       (g : X → X) → 
       (gmonotone : ∀ {x y} → x ⊑ y → g x ⊑ g y) → -- g is monotone

       (x : X) →                 -- inicial value x   
       (x⊑gx : x ⊑ g x) →        -- x ⊑ g x 
       (inv : k ≥ bound x) →     -- invariant
       (x' : X) →                -- inicial value x'   
       (x'⊑gx' : x' ⊑ g x') →    -- x ⊑ g x 
       (inv' : k ≥ bound x') →    -- invariant
       x ⊑ x' → g x ⊑ g x' →   
       proj₁ (fixS X k _⊏_ _⊑_ sum str par bound boundDec minimal g gmonotone x x⊑gx inv) ⊑
       proj₁ (fixS X k _⊏_ _⊑_ sum str par bound boundDec minimal g gmonotone x' x'⊑gx' inv')

fixSmonotone X k rel⊏  rel⊑ sum str par bound boundDec minimal g gmonotone x 
         x⊑gx inv x' x'⊑gx' inv' x⊑x' gx⊑gx' =
      fixSmonotone2 X k rel⊏ rel⊑ sum str par bound boundDec
                    minimal g gmonotone g gmonotone x x⊑gx inv x' x'⊑gx' inv' x⊑x'
                    gx⊑gx' gmonotone 

