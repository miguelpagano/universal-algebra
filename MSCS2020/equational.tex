\section{Equational Logic}
\label{sec:eqlog}

In this section we introduce the notion of (conditional) equational
theories and the corresponding notion of satisfiability of theories
by algebras. Moreover we formalize (conditional) equational logic as
presented by Goguen and Lin \cite{goguen2005specifying} and prove that
the deduction system is sound and complete.

\subsection{Satisfiability and provability}

\paragraph*{Equations} In the mono-sorted setting an equation is a pair
of terms where all the variables are assumed to be universally
quantified and an equational theory is a (finite) set of equations.
In a  multi-sorted setting both sides of an equation should be terms
of the same sort. Moreover we allow quasi-identities which we
write as conditional equations:
\[ t = t'\ \mathsf{if} \  t_1 = t'_1, \ldots, t_n = t'_n \enspace . \]

Let \codigo{Σ| be a signature and |X : sorts Σ → Set} be a family of
variables for \codigo{Σ|. An identity |e : Eq Σ X s} is a pair of (open)
terms with sort \codigo{s}. A conditional equation is modelled as record with
fields for the conclusion and the conditions, modelled as an
heterogeneous vector of sorted identities. We declare a constructor
to use the lighter notation \codigo{⋀ eq if (ar , eqs)| instead of }record {
  eq = e ; cond = (ar , eqs )}|.
\begin{spec}
record Equation (Σ : Signature) (X : sorts Σ → Set) (s : sorts Σ) : Set where
  constructor ⋀_if_
  field
    eq     :   Eq Σ X s
    cond   :   Σ[ ar ∈ List (sorts Σ) ] (HVec (Eq Σ X) ar)
\end{spec}
\noindent A \emph{theory} over the signature $\Sigma$ is given by a
vector of conditional equations.
\begin{spec}
Theory : (Σ : Signature) → (X : sorts Σ → Set) → (ar : List (sorts Σ)) → Set
Theory Σ X ar = HVec (Equation Σ X) ar
\end{spec}
We deviate from Goguen's and Lin's in that we assume that all the
equations of a theory share the same set of variables, while they
assume that each equation has its own set of quantified
variables. Clearly, this simplification is harmless; if we have a
theory where each equation has its own set of variables, we can take
the union of those sets as the common set. As stressed by Goguen and
Meseguer \cite{goguen-remarks-87}, quantifying equations is essential:
\begin{quote}
  [\ldots] the naive unsorted rules of deduction for equational logic
  (namely, reflexivity, symmetry, transitivity and substitutivity) are
  not sound when extended to the many-sorted case in the obvious way;
  [\ldots] adding variable declarations to these rules
  yields a rule set that is sound.
\end{quote}

\comment{\noindent Notice that we follow Goguen and Meseguer in that equations
are given explicitly over a set of variables. This, in turn, leads us
to define satisfiability as proposed by Huet and Oppen.}

\paragraph*{Satisfiability} Let $\Sigma$ be a signature and
$\mathcal{A}$ be an algebra for $\Sigma$. We say that a conditional equation
$t = t'\ \mathsf{if}\ t_1 = t'_1,\ldots,t_n=t'_n$ is
\emph{satisfied} by $\mathcal{A}$ if for any
environment $\theta : X \to \mathcal{A}$, $⟦ t ⟧θ = ⟦ t' ⟧θ$, whenever
$⟦ t_i ⟧θ = ⟦ t'_i ⟧θ$ for $1 \leqslant i \leqslant n$. In order to
formalize satisfiability we first define when an environment models an
equation.
\begin{spec}
_⊨ₑ_ : ∀ {Σ X A} → (θ : Env X A) → {s : sorts Σ} → Eq Σ X s → Set
_⊨ₑ_ θ {s} (t , t') = _≈_ (A ⟦ s ⟧ₛ) (⟦ t ⟧ θ) (⟦ t' ⟧ θ)
\end{spec}
\noindent Using the point-wise extension of this relation we can write
directly the notion of satisfiability.
\begin{spec} 
_⊨_ : ∀ {Σ X} (A : Algebra Σ) → {s : sorts Σ} → Equation Σ X s → Set
A ⊨ (⋀ eq if (_ , eqs)) = ∀ θ → ((θ ⊨ₑ_)* eqs) → θ ⊨ₑ eq
\end{spec}

\noindent We say that $\mathcal{A}$ is a \emph{model} of the theory
$E$ if it satisfies each equation in $E$. As usual an equation is a
logical consequence of a theory, if every model of the theory
satisfies the equation.
\begin{spec}
_⊨ₘ_ : ∀ {Σ X ar} → (A : Algebra Σ) → (E : Theory Σ X ar) → Set
A ⊨ₘ E = (A ⊨_)* E

_⊨Σ_ : ∀ {Σ X ar s} → (E : Theory Σ X ar) → (e : Equation Σ X s) → Set
_⊨Σ_ {Σ} E e = (A : Algebra Σ) → A ⊨ₘ E → A ⊨ e
\end{spec}%

\paragraph*{Provability} As noticed by Huet and Oppen
\cite{huet-rewrite}, the definition of a sound deduction system for
multi-sorted equality logic is more subtle than expected. We formalize
the system presented in \cite{goguen2005specifying}, shown in
Fig.~\ref{fig:deduction}. The first three rules are reflexivity,
symmetry and transitivity; the fourth rule, called substitution,
allows to instantiate an axiom with a substitution \codigo{σ}, provided one
has proofs for every condition of the axiom;\footnote{In our
  formalization this rule is slightly less general because we assume
  all the equations are quantified over the same set of variables.}
finally, the last rule internalizes Leibniz rule, for replacing equals
by equals in subterms.  Notice that we can only prove identities and
not quasi-identities.
\begin{figure}[t]
  \centering
  \bottomAlignProof
  \AxiomC{}
  \UnaryInfC{$E \vdash \forall X,\, t = t$}
  \DisplayProof\hspace{2ex}
%
  \bottomAlignProof
  \AxiomC{$E \vdash \forall X,\, t_0 = t_1$}
  \UnaryInfC{$E \vdash \forall X,\, t_1 = t_0$}
  \DisplayProof \hspace{2ex}
% 
 \bottomAlignProof
 \AxiomC{$E \vdash \forall X,\, t_0 = t_1$}
  \AxiomC{$E \vdash \forall X,\, t_1 = t_2$}
  \BinaryInfC{$E \vdash \forall X,\, t_0 = t_2$}
  \DisplayProof
\\[6pt]
  \AxiomC{$\forall Y,\,t = t' \ \mathsf{if}\
      t_1=t'_1,\ldots, t_n=t'_n \in E$}
  \AxiomC{$E \vdash \forall X,\,\sigma(t_i) = \sigma(t'_i)$}
  \RightLabel{$\sigma \colon Y \rightarrow T_\Sigma(X)$}
  \BinaryInfC{$E \vdash \forall X,\, \sigma(t) = \sigma(t')$}
  \DisplayProof
\\[6pt]
  \AxiomC{$E \vdash \forall X,\, t_1 = t'_1$}
  \AxiomC{$\cdots$}
  \AxiomC{$E \vdash \forall X,\, t_n = t'_n$}
  \RightLabel{$f : [s_1,...,s_{n}] \Rightarrow_{\Sigma} s$}
  \TrinaryInfC{$E \vdash \forall X,\, f\,(t_1,\ldots,t_n) = f\,(t'_1,\ldots,t'_n)$}
  \DisplayProof
  \caption{Deduction system}
  \label{fig:deduction}
\end{figure}
We define the relation of provability as an inductive type,
parameterized in the theory \codigo{E}, and indexed by the conclusion of the
proof. For conciseness, we only show the constructor for transitivity:
\begin{spec}
data _⊢_ {Σ X ar} (E : Theory Σ X ar) : ∀ {s} → Eq Σ X s → Set where
    ptrans : ∀    {s} {t₀ t₁ t₂} →
                  E ⊢ (t₀ , t₁) → E ⊢ (t₁ , t₂) → E ⊢ (t₀ , t₂)
\end{spec}

Let \codigo{E| be a theory over a signature |Σ}. It is straightforward to
define a setoid over \codigo{∣T∣ Σ 〔 X 〕| by letting |t₁ ≈ t₂| if }E ⊢ t₁ ≈
t₂|; this equivalence relation (thanks to the first three rules) is a
congruence (because of the last rule) over the term algebra. We can
also use the facility provided by the standard library to write
proofs with several transitive steps more nicely, as can be seen
in the next example.

Soundness and completeness are proved as in the
mono-sorted case. For soundness one proceeds by induction on the
derivations; completeness is a consequence of the fact that the quotient of the
term algebra by provable equality is a model.
\begin{theorem}[Soundness and Completeness]
  $E \vdash t ≈ t'$ iff $E \models_{\Sigma} t ≈ t'$.
\end{theorem}
\noindent Let us remark that completeness does not imply that there is a
decidability algorithm for every theory; \ie this result gives no decision
procedure at all.

Let $E$ and $E'$ be two theories over the signature $\Sigma$. We say
that $E$ is \emph{stronger} than $E'$ if every axiom $e \in E'$ can be
deduced from $E$, written $E \vdash_{T}\, E'$.  Obviously if $E$
is stronger than $E'$, then any equation that can be deduced from $E'$
can also be deduced from $E$ and any model of $E$ is also a model of
$E'$.

\subsection{Equational classes are closed under IHSP}

Given a class $\mathcal{C}$ of algebras over some signature $\Sigma$
one interesting question is to know whether there it is equational,
ie.\ if there exists some theory $E$ such that the models of $E$ are
exactly those algebras in $\mathcal{C}$. Birkhoff showed that a
sufficient and necessary condition is to be closed under certain
class-operations.

$\mathcal{C}$ is closed under Isomorphism if
$\mathcal{B}\in \mathcal{C}$ whenever $\mathcal{A}\in \mathcal{C}$ and
$\mathcal{A}\simeq \mathcal{B}$. It is closed under products if for
any (arbitrary) family of algebras $\mathcal{A}_i\in \mathcal{C}$ its
direct product $\Pi_{i\in I} \mathcal{A}_i$ is also in
$\mathcal{C}$. Analogously, $\mathcal{C}$ is closed under subalgebras
if $\mathcal{B}\in \mathcal{C}$ for any subalgebra
$\mathcal{B}\leqslant \mathcal{A} \in \mathcal{C}$. Finally, it is
closed under homomorphic images if for any
$\mathcal{A} \in \mathcal{C}$ and epimorhism
$h : \mathcal{A} \to \mathcal{B}$ the homomorphic image of $A$ under
$h$ is also in $\mathcal{C}$. A class closed by these operations is
called a \emph{variety}. Birkhoff proved that every variety is the
class of models of some equational theory.

In our formalization we proved that the class of models of any
equational theory is closed under IHSP. The proof for I, S and P are
almost the same. In the module \AgdaModule{aux-sem} we proved a result
useful for all of them. From an environment for $\mathcal{B}$ and a
homomorphism from $\mathcal{B}$ to $\mathcal{A}$ we have an
environment for $\mathcal{A}$. Moreover the valuations in
$\mathcal{A}$ via the valuation in $\mathcal{B}$ and the homo, on the
one hand, and via the new environment should coincide by the universal
mapping property of the free algebra.

\newcommand{\sem}[2]{\llbracket #1 \rrbracket_{\mathcal{#2}}} In order
to prove, for example, that $\mathcal{C}$ is closed under subalgebras
we assume that $\mathcal{A}$ satisfies the equation and wants to prove
that $\mathcal{B}$ also satifies it; that is, we have to prove
$\sem{t}{B} = \sem{t'}{B}$. Since the equality in a subalgebra is
given by the equality on the underlying algebra of the first
projections, we need to show that $\pi₁ \sem{t}{A} = \pi_1\sem{t'}{A}$
Then we note that $\pi_1$ is the subembedding morphism from $\mathcal{B}$ to
$\mathcal{A}$, therefore we can use the previous result and the satisfaction
of $e$ by $\mathcal{A}$ to conclude that $\mathcal{B}$ also satisfies it.
\begin{code}
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{SubRespects⊨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SubAlgebra}\AgdaSpace{}%
\AgdaBound{B≤A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨}}\AgdaSpace{}%
\AgdaBound{e}\<%
\\
%
\>[2]\AgdaFunction{SubRespects⊨}\AgdaSpace{}%
\AgdaBound{θB}\AgdaSpace{}%
\AgdaBound{B⊨conds}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{proj₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧B}}%
\>[24]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⟦t⟧A≈H⟦t⟧B}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧A}}%
\>[24]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaBound{A⊨e}\AgdaSpace{}%
\AgdaFunction{θA}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⊨B*→⊨A*}\AgdaSpace{}%
\AgdaBound{B⊨conds}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧A}}%
\>[24]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaFunction{⟦t⟧A≈H⟦t⟧B}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[4]\AgdaField{proj₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaField{right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧B}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∎}}\<%
\\
%
\>[4]\AgdaKeyword{where}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{aux-sem}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{SubAlgebra}\AgdaSpace{}%
\AgdaBound{B≤A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{θB}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sub-embedding}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B≤A}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{EqR}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Setoid}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\AgdaSymbol{)}\<%
\end{code}

The satisfaction of semi-equations are not preserved by homomorphic
images; we proved that the satisfaction of non-conditional equations
are preserved by homomorphic images. This result can be reduced to
proving that satisfaction is preserved under quotients, because the
homomorphic image is isomorphic to the source algebra quotiened by
the kernel of the homomorphism.
\begin{code}
\>[3]\AgdaFunction{A/h⊨e}\AgdaSpace{}%
\AgdaBound{θk}\AgdaSpace{}%
\AgdaInductiveConstructor{∼⟨⟩}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaFunction{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧A}}%
\>[25]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaFunction{⟦t⟧A≈H⟦t⟧B}\AgdaSpace{}%
\AgdaFunction{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[5]\AgdaOperator{\AgdaField{′}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaOperator{\AgdaField{′}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟨\$⟩}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaFunction{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧B}}%
\>[26]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaField{Π.cong}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaField{′}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaOperator{\AgdaField{′}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A⊨e}\AgdaSpace{}%
\AgdaFunction{θA}\AgdaSpace{}%
\AgdaInductiveConstructor{∼⟨⟩}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[5]\AgdaOperator{\AgdaField{′}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaOperator{\AgdaField{′}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟨\$⟩}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaFunction{t'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧B}}%
\>[26]\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⟦t⟧A≈H⟦t⟧B}\AgdaSpace{}%
\AgdaFunction{t'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[5]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaFunction{t'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧A}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∎}}\<%
\\
%
\>[5]\AgdaKeyword{where}\<%
\\
%
\>[5]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{EqR}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{A/h}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\AgdaSymbol{)}\<%
\\
%
\>[5]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Setoid}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{A/h}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟦}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaField{⟧ₛ}}\AgdaSymbol{)}\<%
\\
%
\>[5]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{aux-sem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{ℓ₀}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ℓ₀}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{ℓ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ℓ₃}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{ℓ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ℓ₀}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{ℓ₃}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ℓ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaFunction{A/h}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{θk}\AgdaSpace{}%
\AgdaFunction{ν}\<%
%
\\[\AgdaEmptyExtraSkip]%
%
\>[3]\AgdaFunction{equ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Equation}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{s}\<%
\\
%
\>[3]\AgdaFunction{equ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⋀}}\AgdaSpace{}%
\AgdaField{Equ.left}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaField{Equ.right}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[3]\AgdaFunction{imgH⊨e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{homImg}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{H}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊨}}\AgdaSpace{}%
\AgdaFunction{equ}\<%
\\
%
\>[3]\AgdaFunction{imgH⊨e}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{IsoRespects⊨}\AgdaSpace{}%
\AgdaFunction{A/h⊨e}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaKeyword{where}\AgdaSpace{}%
\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{IsoRespectSatisfaction}\AgdaSpace{}%
\AgdaFunction{equ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{I.iso-A/kerH}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{H}\AgdaSymbol{)}\<%
\end{code}

% This forced us to introduce a
% notion of non-conditional equations and unconditional equational
% theory.

It is our immediate next goal to prove the converse, namely giving an
equational theory for any class closed by HSP. In the development
branch of our formalization\footnote{repository URL} we have some
preliminaries definitions such as a more general notion of free
algebras, congruences generated by some relation, and more results
about sub-algebras.

One application that models of equational theories are closed under
IHSP is to prove that some theories are not equational
axiomatizable. We proved that fields are not equational because they
are not closed under products (of course, the problem is that an
equational lacks negations). Our approach to proving this, was to
introduce a shallow notion of fields (ie. we do not have a syntactic
representation of fields, but we model them as setoids with operations
satisfying the axioms) and assume that there is an equational theory
modelling them. We can easily turn $\mathit{Bool}$ into a field with
the xor and conjunction operations. %COMPLETAR.
% Decir que tomar a≠b como ¬(a=b) se llama tight apartness

In the standard library there are shallow definitions of several
algebraic structures (from magmas up to commutative rings) but it
lacks the product bi-functor. We have defined an interface between
models of the deep embeddings of those structures (in our library)
with those of the standard library. In this way we get by closedness
of products a product of shallow monoids.

\subsection{A theory for Boolean Algebras } In this section we outline
how to formalize an equational theory and illustrate each step by
showing snippets of the formalization of a Boolean Theory presented by
Rocha and Meseguer~\cite{DBLP:conf/RelMiCS/RochaM08}.\footnote{The
  full code is available in the file \nolinkurl{Examples/EqBool.agda}
  of the repository.}

\paragraph*{Define the signature}
\label{sec:define-signature} describing the language, and choose
  a family of sets for the variables. It helps if one also introduce
  an abbreviation for terms over the signature extended with
  variables.
\begin{spec}
data bool-ops : List ⊤ × ⊤ → Set where
  f t    : bool-ops ([] ↦ tt)
  neg  : bool-ops ([ tt ] ↦ tt)
  and or  : bool-ops (([ tt , tt ]) ↦ tt)

bool-sig : Signature
bool-sig = record { sorts = ⊤ ; ops = bool-ops }
vars : sorts bool-sig → Set
vars tt = ℕ

Form : Set
Form = HU bool-sig 〔 vars 〕
\end{spec}

\paragraph*{Introduce smart-constructors}
\label{sec:intr-smart-constr}
  for terms of the extended
  signature with variables to ease writing the axioms and proving
  theorems. Usually one has a smart-constructor for each operation and
  one per variable that is used in the axioms or the theorems.
\begin{spec}
true false : Form
true = term (inj₁ t) ⟨⟩
false = term (inj₁ f) ⟨⟩

p q  : Form
p = term (inj₂ 0) ⟨⟩
q = term (inj₂ 1) ⟨⟩

_∧_ : Form → Form → Form
φ ∧ ψ = term and ⟨⟨ φ , ψ ⟩⟩

¬ : Form → Form
¬ φ = term neg ⟨⟨ φ ⟩⟩
\end{spec}

\paragraph*{Define the equational theory}
\label{sec:define-equat-theory}

 by specifying one equation for
  each axiom and collect them in a theory; here one can appreciate the
  convenience of the smart-constructors. Here we only show two of the
  twelve axioms of the theory \codigo{bool-theory}. If one will prove theorems
  of the theory, then it is also convenient to define pattern-synonyms
  for the proofs that each axiom is in the theory.
\begin{spec}
commAnd leastDef : Equation bool-sig vars tt
commAnd = ⋀ (p ∧ q) ≈ (q ∧ p) if ([] , ⟨⟩)
leastDef = ⋀ (p ∧ (¬ p)) ≈ false  if ([] , ⟨⟩)

bool-theory : Theory bool-sig vars [ tt , tt , … ]
bool-theory = ⟨ commAnd , leastDef , … ⟩

pattern commAndAx = here
pattern leastDefAx = there here
\end{spec}

\paragraph*{Prove theorems}
  using the axioms of the theory just defined.
  If a proof uses transitivity, one can use the equational reasoning
  idiom provided by the standard library of Agda:
\begin{spec}
  p₁ : bool-theory ⊢ (⋀ ¬ p ∧ p ≈ false)
  p₁ = begin
         ¬ p ∧ p
         ≈⟨ psubst commAndAx σ₁ ∼⟨⟩ ⟩
         p ∧ ¬ p
         ≈⟨ psubst leastDefAx idSubst ∼⟨⟩ ⟩
         false
       ∎
\end{spec}
\noindent In the justification steps of this proof we use the
substitution rule. The relevant actions of the substitution \codigo{σ₁} are
\codigo{σ₁ p = ¬ p| and |σ₁ q = p}.


